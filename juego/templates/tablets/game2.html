<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Misi√≥n Emprende - Juego</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, Cantarell, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        @keyframes pulse {
            0%, 100% {
                transform: scale(1);
                opacity: 1;
            }
            50% {
                transform: scale(1.1);
                opacity: 0.8;
            }
        }

        .header {
            background: white;
            border-radius: 15px;
            padding: 15px 20px;
            margin-bottom: 20px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
        }

        .team-info {
            display: flex;
            align-items: center;
            gap: 15px;
        }

        .team-color {
            width: 40px;
            height: 40px;
            border-radius: 50%;
            display: flex;
            align-items: center;
            justify-content: center;
            font-weight: bold;
            font-size: 18px;
            color: white;
            box-shadow: 0 3px 10px rgba(0, 0, 0, 0.2);
        }

        .team-details h3 {
            color: #333;
            font-size: 18px;
            margin-bottom: 2px;
        }

        .team-details p {
            color: #666;
            font-size: 12px;
        }

        .tokens-badge {
            background: #667eea;
            color: white;
            padding: 8px 18px;
            border-radius: 25px;
            font-size: 16px;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .container {
            max-width: 900px;
            margin: 0 auto;
        }

        /* Modal de Explicaci√≥n de Etapa */
        .stage-modal {
            display: none;
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0, 0, 0, 0.7);
            z-index: 1000;
            justify-content: center;
            align-items: center;
            padding: 20px;
        }

        .stage-modal.show {
            display: flex;
        }

        .stage-modal-content {
            background: white;
            border-radius: 20px;
            padding: 40px;
            max-width: 600px;
            width: 100%;
            max-height: 90vh;
            overflow-y: auto;
            position: relative;
            box-shadow: 0 20px 60px rgba(0, 0, 0, 0.3);
            animation: slideIn 0.3s ease-out;
        }

        @keyframes slideIn {
            from {
                transform: translateY(-50px);
                opacity: 0;
            }
            to {
                transform: translateY(0);
                opacity: 1;
            }
        }

        .modal-close {
            position: absolute;
            top: 15px;
            right: 15px;
            background: #f8f9fa;
            border: none;
            width: 35px;
            height: 35px;
            border-radius: 50%;
            font-size: 20px;
            cursor: pointer;
            display: flex;
            align-items: center;
            justify-content: center;
            color: #666;
            transition: all 0.3s;
        }

        .modal-close:hover {
            background: #e9ecef;
            color: #333;
            transform: rotate(90deg);
        }

        .stage-icon {
            font-size: 60px;
            text-align: center;
            margin-bottom: 20px;
        }

        .stage-title {
            color: #667eea;
            font-size: 28px;
            text-align: center;
            margin-bottom: 15px;
            font-weight: 700;
        }

        .stage-objective {
            background: #f0f4ff;
            padding: 20px;
            border-radius: 15px;
            margin-bottom: 20px;
            border-left: 4px solid #667eea;
        }

        .stage-objective h4 {
            color: #667eea;
            font-size: 18px;
            margin-bottom: 10px;
        }

        .stage-objective p {
            color: #666;
            font-size: 16px;
            line-height: 1.6;
        }

        .stage-description {
            color: #333;
            font-size: 16px;
            line-height: 1.8;
            margin-bottom: 20px;
        }

        .stage-duration {
            background: #fff3cd;
            padding: 15px;
            border-radius: 10px;
            text-align: center;
            color: #856404;
            font-weight: 600;
        }

        /* Actividad de Personalizaci√≥n */
        .activity-container {
            background: white;
            border-radius: 15px;
            padding: 30px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            display: none;
        }

        .activity-container.active {
            display: block;
        }

        .activity-title {
            color: #333;
            font-size: 24px;
            margin-bottom: 10px;
        }

        .activity-subtitle {
            color: #666;
            font-size: 16px;
            margin-bottom: 30px;
        }

        .form-group {
            margin-bottom: 25px;
        }

        .form-group label {
            display: block;
            margin-bottom: 8px;
            color: #333;
            font-weight: 600;
            font-size: 14px;
        }

        .form-group input {
            width: 100%;
            padding: 15px;
            border: 2px solid #e0e0e0;
            border-radius: 10px;
            font-size: 16px;
            transition: all 0.3s;
        }

        .form-group input:focus {
            outline: none;
            border-color: #667eea;
            box-shadow: 0 0 0 3px rgba(102, 126, 234, 0.1);
        }

        .know-buttons {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 15px;
            margin-top: 10px;
        }

        .know-btn {
            padding: 20px;
            border: 3px solid #e0e0e0;
            border-radius: 15px;
            background: white;
            cursor: pointer;
            transition: all 0.3s;
            font-size: 16px;
            font-weight: 600;
            color: #666;
            text-align: center;
        }

        .know-btn:hover {
            border-color: #667eea;
            background: #f0f4ff;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.2);
        }

        .know-btn.selected {
            border-color: #667eea;
            background: #667eea;
            color: white;
        }

        .know-btn .icon {
            font-size: 32px;
            margin-bottom: 10px;
            display: block;
        }

        .submit-btn {
            width: 100%;
            padding: 15px;
            background: #667eea;
            color: white;
            border: none;
            border-radius: 10px;
            font-size: 18px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-top: 20px;
        }

        .submit-btn:hover {
            background: #5568d3;
            transform: translateY(-2px);
            box-shadow: 0 5px 15px rgba(102, 126, 234, 0.4);
        }

        .submit-btn:disabled {
            background: #ccc;
            cursor: not-allowed;
            transform: none;
        }

        .alert {
            padding: 15px;
            border-radius: 10px;
            margin-bottom: 20px;
            display: none;
        }

        .alert.show {
            display: block;
        }

        .alert-success {
            background: #d4edda;
            color: #155724;
            border: 1px solid #c3e6cb;
        }

        .alert-error {
            background: #f8d7da;
            color: #721c24;
            border: 1px solid #f5c6cb;
        }

        .loading {
            text-align: center;
            padding: 40px;
            display: none;
        }

        .loading.show {
            display: block;
        }

        .loading-spinner {
            border: 4px solid #f3f3f3;
            border-top: 4px solid #667eea;
            border-radius: 50%;
            width: 50px;
            height: 50px;
            animation: spin 1s linear infinite;
            margin: 0 auto 20px;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .waiting-message {
            text-align: center;
            padding: 40px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
        }

        .waiting-icon {
            font-size: 60px;
            margin-bottom: 20px;
        }

        .waiting-text {
            color: #666;
            font-size: 18px;
        }

        /* Resultados de Etapa */
        .stage-info-box {
            text-align: center;
            margin-bottom: 30px;
            padding: 20px;
            background: #f0f4ff;
            border-radius: 15px;
        }

        .stage-icon-large {
            font-size: 70px;
            margin-bottom: 15px;
        }

        .results-summary {
            margin-top: 20px;
        }

        .waiting-next-stage {
            text-align: center;
            padding: 40px;
            background: white;
            border-radius: 15px;
            box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);
            margin-top: 20px;
        }
    </style>
</head>
<body>
    <div class="header">
        <div class="team-info">
            <div class="team-color" id="teamColor" style="background: #667eea;">?</div>
            <div class="team-details">
                <h3 id="teamName">Equipo</h3>
                <p id="teamInfo">Cargando...</p>
            </div>
        </div>
        <div class="tokens-badge">
            ü™ô <span id="tokensCount">0</span> Tokens
        </div>
    </div>

    <div class="container">
        <div id="alertContainer"></div>

        <!-- Modal de Explicaci√≥n de Etapa -->
        <div class="stage-modal" id="stageModal">
            <div class="stage-modal-content">
                <button class="modal-close" onclick="closeStageModal()">√ó</button>
                <div class="stage-icon" id="stageIcon">üë•</div>
                <h2 class="stage-title" id="stageTitle">Etapa 1: Trabajo en Equipo</h2>
                <div class="stage-objective">
                    <h4>üéØ Objetivo</h4>
                    <p id="stageObjective">Conocerse o fortalecer compa√±erismo</p>
                </div>
                <div class="stage-description" id="stageDescription">
                    En esta etapa, trabajar√°s junto a tu equipo para conoceros mejor y fortalecer vuestro v√≠nculo. 
                    Realizar√°s actividades que te ayudar√°n a entender mejor a tus compa√±eros y a trabajar juntos de manera m√°s efectiva.
                </div>
                <div class="stage-duration">
                    ‚è±Ô∏è Duraci√≥n estimada: 15-20 minutos
                </div>
            </div>
        </div>

        <!-- Actividad de Personalizaci√≥n -->
        <div class="activity-container" id="personalizationActivity">
            <h2 class="activity-title">1. Personalizaci√≥n del Equipo</h2>
            <p class="activity-subtitle">Define el nombre de tu equipo y si ya se conocen entre ustedes</p>
            
            <!-- Temporizador -->
            <div id="timerContainerPersonalization" style="background: #fff3cd; padding: 12px; border-radius: 8px; margin-bottom: 20px; text-align: center; border: 2px solid #ffc107;">
                <p style="margin: 0; color: #856404; font-weight: 600; font-size: 16px;">
                    ‚è±Ô∏è Tiempo restante: <span id="timerDisplayPersonalization">--:--</span>
                </p>
            </div>

            <form id="personalizationForm" onsubmit="handlePersonalizationSubmit(event)">
                <div class="form-group">
                    <label for="teamNameInput">Nombre del Equipo</label>
                    <input 
                        type="text" 
                        id="teamNameInput" 
                        name="teamName" 
                        placeholder="Ej: Los Emprendedores, Los Innovadores..."
                        maxlength="100"
                        required
                        autocomplete="off"
                    >
                </div>

                <div class="form-group">
                    <label>¬øLos miembros del equipo ya se conocen?</label>
                    <div class="know-buttons">
                        <button type="button" class="know-btn" onclick="selectKnowOption(true)" id="knowYesBtn">
                            <span class="icon">üëã</span>
                            Ya nos conocemos
                        </button>
                        <button type="button" class="know-btn" onclick="selectKnowOption(false)" id="knowNoBtn">
                            <span class="icon">üë•</span>
                            No nos conocemos
                        </button>
                    </div>
                </div>

                <button type="submit" class="submit-btn" id="submitBtn">
                    Entregar Personalizaci√≥n
                </button>
            </form>
        </div>

        <!-- Actividad de Presentaci√≥n - Anagramas (para equipos que se conocen) -->
        <div class="activity-container" id="anagramActivity">
            <h2 class="activity-title">2. Presentaci√≥n - Minijuego de Anagramas</h2>
            <p class="activity-subtitle">Adivina las palabras desordenadas. Cada palabra correcta vale 5 tokens</p>

            <!-- Temporizador -->
            <div id="timerContainer" style="background: #fff3cd; padding: 15px; border-radius: 10px; margin-bottom: 20px; text-align: center; border: 2px solid #ffc107;">
                <p style="margin: 0; color: #856404; font-weight: 600; font-size: 18px;">
                    ‚è±Ô∏è Tiempo restante: <span id="timerDisplay">--:--</span>
                </p>
            </div>

            <div id="anagramExplanation" style="background: #f0f4ff; padding: 15px; border-radius: 10px; margin-bottom: 20px; border-left: 4px solid #667eea;">
                <p style="margin: 0; color: #667eea; font-weight: 600;">üìù Instrucciones:</p>
                <p style="margin: 5px 0 0 0; color: #555;">Las palabras est√°n desordenadas. Reordena las letras para formar la palabra correcta. Se enviar√° autom√°ticamente cuando escribas la respuesta correcta.</p>
            </div>

            <div id="anagramWordsContainer">
                <!-- Se mostrar√° solo 1 anagrama a la vez -->
            </div>

            <div id="anagramProgress" style="margin-top: 20px; text-align: center; color: #666;">
                <p>Palabra <span id="currentWordNumber">1</span> de <span id="totalWords">3</span></p>
            </div>
        </div>

        <!-- Actividad de Presentaci√≥n - Hablar (para equipos que NO se conocen) -->
        <div class="activity-container" id="presentationActivity">
            <h2 class="activity-title">2. Presentaci√≥n - Con√≥cenos</h2>
            <p class="activity-subtitle">T√≥mate un tiempo para presentarte con tu equipo</p>

            <!-- Temporizador -->
            <div id="timerContainerPresentation" style="background: #fff3cd; padding: 15px; border-radius: 10px; margin-bottom: 20px; text-align: center; border: 2px solid #ffc107;">
                <p style="margin: 0; color: #856404; font-weight: 600; font-size: 18px;">
                    ‚è±Ô∏è Tiempo restante: <span id="timerDisplayPresentation">--:--</span>
                </p>
            </div>

            <div id="presentationExplanation" style="background: #e7f3ff; padding: 20px; border-radius: 10px; margin-bottom: 20px; border-left: 4px solid #2196F3;">
                <p style="margin: 0; color: #1976D2; font-weight: 600; font-size: 16px;">üëã ¬°Es momento de conocerse!</p>
                <p style="margin: 10px 0 0 0; color: #555; line-height: 1.6;">
                    Como no se conocen a√∫n, t√≥mense un tiempo para presentarse. Cada miembro del equipo debe compartir:
                </p>
                <ul style="margin: 10px 0 0 20px; color: #555;">
                    <li>Su nombre</li>
                    <li>Algo sobre ellos (intereses, hobbies, etc.)</li>
                    <li>Qu√© esperan de esta experiencia</li>
                </ul>
                <p style="margin: 15px 0 0 0; color: #666; font-style: italic;">
                    Cuando todos hayan terminado de presentarse, presiona el bot√≥n "Listo" para continuar.
                </p>
            </div>

            <button type="button" class="submit-btn" id="presentationDoneBtn" onclick="handlePresentationDone()">
                ‚úì Listo - Hemos terminado de presentarnos
            </button>
        </div>

        <!-- Actividad de Selecci√≥n de Tema (Etapa 2) -->
        <div class="activity-container" id="topicSelectionActivity">
            <h2 class="activity-title">1. Seleccionar Tema</h2>
            <p class="activity-subtitle">Elige un tema de inter√©s relacionado con tu facultad</p>

            <!-- Temporizador -->
            <div id="timerContainerTopic" style="background: #fff3cd; padding: 15px; border-radius: 10px; margin-bottom: 20px; text-align: center; border: 2px solid #ffc107;">
                <p style="margin: 0; color: #856404; font-weight: 600; font-size: 18px;">
                    ‚è±Ô∏è Tiempo restante: <span id="timerDisplayTopic">--:--</span>
                </p>
            </div>

            <div id="topicsContainer" style="display: grid; gap: 15px;">
                <!-- Los temas se cargar√°n din√°micamente -->
            </div>

            <div id="selectedTopicInfo" style="display: none; background: #d4edda; padding: 15px; border-radius: 10px; margin-top: 20px; border-left: 4px solid #28a745;">
                <p style="margin: 0; color: #155724; font-weight: 600; margin-bottom: 10px;">‚úì Tema seleccionado: <span id="selectedTopicName"></span></p>
                <button type="button" class="submit-btn" onclick="confirmTopicSelection()" id="confirmTopicBtn">
                    ‚úì Confirmar Selecci√≥n
                </button>
            </div>
        </div>

        <!-- Actividad de Ver Desaf√≠o (Etapa 2) -->
        <div class="activity-container" id="challengeViewActivity">
            <h2 class="activity-title">2. Ver el Desaf√≠o</h2>
            <p class="activity-subtitle">Lee y analiza el desaf√≠o asociado a tu tema</p>

            <!-- Temporizador -->
            <div id="timerContainerChallenge" style="background: #fff3cd; padding: 15px; border-radius: 10px; margin-bottom: 20px; text-align: center; border: 2px solid #ffc107;">
                <p style="margin: 0; color: #856404; font-weight: 600; font-size: 18px;">
                    ‚è±Ô∏è Tiempo restante: <span id="timerDisplayChallenge">--:--</span>
                </p>
            </div>

            <!-- Lista de desaf√≠os para seleccionar -->
            <div id="challengesContainer" style="display: grid; gap: 15px; margin-bottom: 20px;">
                <!-- Los desaf√≠os se cargar√°n din√°micamente -->
            </div>

            <!-- Informaci√≥n del desaf√≠o seleccionado y bot√≥n de confirmar -->
            <div id="selectedChallengeInfo" style="background: #f8f9fa; padding: 15px; border-radius: 10px; margin-bottom: 20px; display: none;">
                <p style="margin: 0; color: #666; font-size: 14px;">
                    Desaf√≠o seleccionado: <strong id="selectedChallengeName" style="color: #667eea;"></strong>
                </p>
                <button type="button" class="submit-btn" onclick="confirmChallengeSelection()" id="confirmChallengeBtn">
                    ‚úì Confirmar Selecci√≥n
                </button>
            </div>
        </div>

        <!-- Actividad de Bubble Map (Etapa 2) -->
        <div class="activity-container" id="bubbleMapActivity">
            <h2 class="activity-title">3. Bubble Map</h2>
            <p class="activity-subtitle">Crea un mapa mental con ideas y conceptos relacionados al desaf√≠o</p>

            <!-- Temporizador -->
            <div id="timerContainerBubbleMap" style="background: #fff3cd; padding: 15px; border-radius: 10px; margin-bottom: 20px; text-align: center; border: 2px solid #ffc107;">
                <p style="margin: 0; color: #856404; font-weight: 600; font-size: 18px;">
                    ‚è±Ô∏è Tiempo restante: <span id="timerDisplayBubbleMap">--:--</span>
                </p>
            </div>

            <div style="background: #f0f4ff; padding: 15px; border-radius: 10px; margin-bottom: 20px; border-left: 4px solid #667eea;">
                <p style="margin: 0; color: #667eea; font-weight: 600;">üí° Instrucciones:</p>
                <p style="margin: 5px 0 0 0; color: #555;">Agrega burbujas con ideas, conceptos o problemas relacionados al desaf√≠o. Haz clic en "Agregar Burbuja" para crear nuevas ideas.</p>
            </div>

            <div style="margin-bottom: 20px;">
                <button type="button" class="btn" onclick="addBubbleNode()" style="background: #667eea; color: white; padding: 12px 20px; border: none; border-radius: 8px; font-weight: 600; cursor: pointer;">
                    + Agregar Burbuja
                </button>
            </div>

            <div id="bubbleMapCanvas" style="min-height: 300px; background: #f8f9fa; border-radius: 10px; padding: 20px; position: relative; border: 2px dashed #ddd;">
                <!-- Las burbujas se mostrar√°n aqu√≠ -->
                <div id="bubbleMapEmpty" style="text-align: center; color: #999; padding: 40px; font-style: italic;">
                    No hay burbujas a√∫n. Haz clic en "Agregar Burbuja" para comenzar.
                </div>
            </div>

            <div style="margin-top: 20px;">
                <button type="button" class="submit-btn" onclick="saveBubbleMap()">
                    üíæ Guardar Bubble Map
                </button>
            </div>
        </div>

        <!-- Actividad de Subida de Prototipo (Etapa 3) -->
        <div class="activity-container" id="prototypeUploadActivity">
            <h2 class="activity-title">1. Subida de Prototipo Lego</h2>
            <p class="activity-subtitle">Construye f√≠sicamente tu prototipo con legos y s√∫belo aqu√≠</p>

            <!-- Temporizador -->
            <div id="timerContainerPrototype" style="background: #fff3cd; padding: 15px; border-radius: 10px; margin-bottom: 20px; text-align: center; border: 2px solid #ffc107;">
                <p style="margin: 0; color: #856404; font-weight: 600; font-size: 18px;">
                    ‚è±Ô∏è Tiempo restante: <span id="timerDisplayPrototype">--:--</span>
                </p>
            </div>

            <!-- Explicaci√≥n sobre qu√© construir con legos -->
            <div style="background: #e8f5e9; padding: 20px; border-radius: 10px; margin-bottom: 20px; border-left: 4px solid #4caf50;">
                <p style="margin: 0; color: #2e7d32; font-weight: 700; font-size: 18px; margin-bottom: 10px;">üß± ¬øQu√© construir con legos?</p>
                <p style="margin: 0; color: #555; font-size: 16px; line-height: 1.6;">
                    Bas√°ndote en el desaf√≠o que seleccionaste en la Etapa 2 (Empat√≠a), construye un <strong>prototipo f√≠sico con legos</strong> que represente tu soluci√≥n al problema identificado.
                </p>
                <p style="margin: 10px 0 0 0; color: #555; font-size: 16px; line-height: 1.6;">
                    El prototipo debe ser una representaci√≥n tangible de c√≥mo tu equipo imagina que se podr√≠a resolver el desaf√≠o. Usa los legos para crear una maqueta, modelo o representaci√≥n visual de tu soluci√≥n.
                </p>
            </div>

            <div style="background: #f0f4ff; padding: 15px; border-radius: 10px; margin-bottom: 20px; border-left: 4px solid #667eea;">
                <p style="margin: 0; color: #667eea; font-weight: 600;">üìã Instrucciones para subir el prototipo:</p>
                <p style="margin: 5px 0 0 0; color: #555; line-height: 1.8;">
                    1. Construye f√≠sicamente tu prototipo con legos<br>
                    2. Toma una foto del prototipo con la c√°mara de la tablet<br>
                    3. O sube una imagen desde la galer√≠a<br>
                    4. Revisa la vista previa y confirma la subida
                </p>
            </div>

            <!-- Contenedor para subir prototipo -->
            <div id="prototypeUploadContainer" style="background: white; padding: 30px; border-radius: 10px; margin-bottom: 20px; text-align: center;">
                <input type="file" id="prototypeImageInput" accept="image/*" capture="environment" style="display: none;" onchange="handleImageSelect(event)">
                <div style="margin-bottom: 20px;">
                    <p style="color: #666; font-size: 16px; margin-bottom: 20px; font-weight: 500;">Cuando hayas terminado de construir tu prototipo con legos, toma una foto o sube una imagen:</p>
                    <button type="button" class="btn" onclick="document.getElementById('prototypeImageInput').click()" style="background: #667eea; color: white; padding: 18px 40px; border: none; border-radius: 12px; font-weight: 700; cursor: pointer; font-size: 18px; box-shadow: 0 4px 12px rgba(102, 126, 234, 0.4); transition: all 0.3s; display: inline-block;">
                        üì∑ Tomar Foto o Seleccionar Imagen
                    </button>
                    <p style="color: #999; font-size: 13px; margin-top: 15px; font-style: italic;">Puedes usar la c√°mara de la tablet o seleccionar una imagen de la galer√≠a</p>
                </div>
                
                <div id="prototypePreview" style="display: none; margin-top: 20px;">
                    <img id="prototypePreviewImage" src="" alt="Vista previa" style="max-width: 100%; max-height: 400px; border-radius: 10px; margin-bottom: 15px;">
                    <div>
                        <button type="button" class="btn" onclick="cancelImageSelection()" style="background: #dc3545; color: white; padding: 10px 20px; border: none; border-radius: 8px; font-weight: 600; cursor: pointer; margin-right: 10px;">
                            ‚úñÔ∏è Cancelar
                        </button>
                        <button type="button" class="submit-btn" onclick="uploadPrototype()">
                            ‚úì Subir Prototipo
                        </button>
                    </div>
                </div>
            </div>

            <!-- Contenedor para mostrar prototipo subido (fuera del contenedor de subida) -->
            <div id="prototypeUploaded" style="display: none; background: white; padding: 30px; border-radius: 10px; margin-bottom: 20px; text-align: center;">
                <div style="background: #d4edda; padding: 15px; border-radius: 10px; border: 2px solid #28a745;">
                    <p style="margin: 0; color: #155724; font-weight: 600; font-size: 18px;">‚úì Prototipo subido exitosamente</p>
                    <img id="prototypeUploadedImage" src="" alt="Prototipo subido" style="max-width: 100%; max-height: 400px; border-radius: 10px; margin-top: 15px;">
                </div>
            </div>
        </div>

        <!-- Actividad de Formulario de Pitch (Etapa 4) -->
        <div class="activity-container" id="pitchFormActivity">
            <h2 class="activity-title">1. Formulario de Pitch</h2>
            <p class="activity-subtitle">Completa el formulario para crear tu pitch: intro-problema, soluci√≥n y cierre</p>

            <!-- Temporizador -->
            <div id="timerContainerPitch" style="background: #fff3cd; padding: 15px; border-radius: 10px; margin-bottom: 20px; text-align: center; border: 2px solid #ffc107;">
                <p style="margin: 0; color: #856404; font-weight: 600; font-size: 18px;">
                    ‚è±Ô∏è Tiempo restante: <span id="timerDisplayPitch">--:--</span>
                </p>
            </div>

            <div style="background: #e7f3ff; padding: 20px; border-radius: 10px; margin-bottom: 20px; border-left: 4px solid #2196F3;">
                <p style="margin: 0; color: #1976D2; font-weight: 600; font-size: 16px;">üìù Crea tu guion para presentar</p>
                <p style="margin: 10px 0 0 0; color: #555; line-height: 1.6;">
                    Completa los tres campos del formulario para crear el guion de tu pitch. Bas√°ndote en lo que trabajaste en las etapas anteriores:
                </p>
                <ul style="margin: 10px 0 0 20px; color: #555;">
                    <li><strong>Introducci√≥n del Problema:</strong> Usa el tema y desaf√≠o que seleccionaste en la Etapa 2 (Empat√≠a)</li>
                    <li><strong>Soluci√≥n:</strong> Describe tu soluci√≥n bas√°ndote en el prototipo que construiste en la Etapa 3 (Creatividad)</li>
                    <li><strong>Cierre:</strong> Concluye tu pitch de manera impactante</li>
                </ul>
            </div>

            <form id="pitchForm" onsubmit="handlePitchFormSubmit(event)">
                <div class="form-group">
                    <label for="pitchIntroProblem">üìã Introducci√≥n del Problema</label>
                    <textarea 
                        id="pitchIntroProblem" 
                        name="pitchIntroProblem" 
                        rows="4"
                        placeholder="Describe el problema que identificaste en la Etapa 2 (Empat√≠a)..."
                        required
                    ></textarea>
                </div>

                <div class="form-group">
                    <label for="pitchSolution">üí° Soluci√≥n</label>
                    <textarea 
                        id="pitchSolution" 
                        name="pitchSolution" 
                        rows="4"
                        placeholder="Describe tu soluci√≥n bas√°ndote en el prototipo de la Etapa 3 (Creatividad)..."
                        required
                    ></textarea>
                </div>

                <div class="form-group">
                    <label for="pitchClosing">üéØ Cierre</label>
                    <textarea 
                        id="pitchClosing" 
                        name="pitchClosing" 
                        rows="4"
                        placeholder="Concluye tu pitch de manera impactante..."
                        required
                    ></textarea>
                </div>

                <button type="submit" class="submit-btn" id="submitPitchBtn">
                    ‚úì Guardar Pitch
                </button>
            </form>

            <div id="pitchSavedMessage" style="display: none; background: #d4edda; padding: 15px; border-radius: 10px; margin-top: 20px; border: 2px solid #28a745;">
                <p style="margin: 0; color: #155724; font-weight: 600; font-size: 16px;">‚úì Pitch guardado exitosamente</p>
            </div>
        </div>

        <!-- Actividad de Presentaci√≥n del Pitch (Etapa 4) -->
        <div class="activity-container" id="pitchPresentationActivity">
            <h2 class="activity-title">2. Presentaci√≥n del Pitch</h2>
            <p class="activity-subtitle">Presenta tu pitch y eval√∫a a tus compa√±eros</p>

            <!-- Orden de presentaci√≥n -->
            <div id="presentationOrderContainer" style="display: none; background: #e7f3ff; padding: 20px; border-radius: 10px; margin-bottom: 20px; border-left: 4px solid #2196F3;">
                <h3 style="color: #1976D2; font-size: 18px; margin-bottom: 15px;">üìã Orden de Presentaci√≥n</h3>
                <div id="presentationOrderList" style="display: flex; flex-direction: column; gap: 10px;"></div>
            </div>

            <!-- Estado de espera (orden no confirmado) -->
            <div id="waitingForOrder" style="background: #fff3cd; padding: 30px; border-radius: 10px; text-align: center; border: 2px solid #ffc107;">
                <div style="font-size: 48px; margin-bottom: 15px;">‚è≥</div>
                <p style="color: #856404; font-weight: 600; font-size: 18px;">Esperando a que el profesor confirme el orden de presentaci√≥n...</p>
            </div>

            <!-- Pantalla de transici√≥n: "Te toca presentar" -->
            <div id="presentationReadyContainer" style="display: none; background: linear-gradient(135deg, #667eea 0%, #764ba2 100%); padding: 40px; border-radius: 15px; margin-bottom: 20px; text-align: center; color: white;">
                <div style="font-size: 80px; margin-bottom: 20px;">üé§</div>
                <h2 style="color: white; font-size: 32px; font-weight: 700; margin-bottom: 15px;" id="presentationReadyTeamName">Te toca presentar</h2>
                <p style="color: rgba(255,255,255,0.9); font-size: 20px; margin-bottom: 30px;">El profesor iniciar√° tu presentaci√≥n cuando est√© listo</p>
                <div style="font-size: 60px; animation: pulse 2s infinite;">‚è≥</div>
            </div>

            <!-- Tu turno de presentar -->
            <div id="yourTurnContainer" style="display: none; background: #d4edda; padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid #28a745;">
                <div style="text-align: center; margin-bottom: 20px;">
                    <div style="font-size: 48px; margin-bottom: 10px;">üé§</div>
                    <h3 style="color: #155724; font-size: 24px; font-weight: 700; margin-bottom: 10px;">¬°Es tu turno!</h3>
                    <p style="color: #155724; font-size: 16px;">Presenta tu pitch adelante. Puedes usar el prototipo y la tablet como apoyo.</p>
                </div>

                <!-- Temporizador -->
                <div id="timerContainerPitchPresentation" style="background: #fff3cd; padding: 15px; border-radius: 10px; margin-bottom: 20px; text-align: center; border: 2px solid #ffc107;">
                    <p style="margin: 0; color: #856404; font-weight: 600; font-size: 18px;">
                        ‚è±Ô∏è Tiempo restante: <span id="timerDisplayPitchPresentation">--:--</span>
                    </p>
                </div>

                <!-- Pitch completo -->
                <div id="yourPitchDisplay" style="background: white; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                    <h4 style="color: #333; font-size: 18px; margin-bottom: 15px;">üìù Tu Pitch:</h4>
                    <div id="pitchContentDisplay"></div>
                </div>

                <button class="submit-btn" onclick="markPresentationDone()" id="markPresentationDoneBtn">
                    ‚úì Complet√© mi Presentaci√≥n
                </button>
            </div>

            <!-- Esperando turno / Otro equipo presentando -->
            <div id="waitingTurnContainer" style="display: none;">
                <!-- Mostrar primero qui√©n est√° presentando -->
                <div id="currentPresenterInfo" style="background: #fff3cd; padding: 20px; border-radius: 10px; margin-bottom: 20px; text-align: center; border: 2px solid #ffc107;">
                    <div style="font-size: 48px; margin-bottom: 10px;">üéôÔ∏è</div>
                    <h3 style="color: #856404; font-size: 20px; font-weight: 700; margin-bottom: 10px;" id="currentPresenterName">Turno del equipo...</h3>
                    <p style="color: #856404; font-size: 16px;">Escucha atentamente la presentaci√≥n</p>
                </div>

                <!-- Prototipo del equipo que est√° presentando -->
                <div id="presenterPrototypeContainer" style="background: white; padding: 20px; border-radius: 10px; margin-bottom: 20px;">
                    <h4 style="color: #333; font-size: 18px; margin-bottom: 15px;">üß± Prototipo del Equipo:</h4>
                    <div id="presenterPrototypeImage" style="text-align: center;">
                        <p style="color: #999;">Cargando prototipo...</p>
                    </div>
                </div>

                <!-- Formulario de evaluaci√≥n (despu√©s de la presentaci√≥n) - Se muestra al final -->
                <div id="evaluationFormContainer" style="display: none; background: white; padding: 20px; border-radius: 10px; margin-bottom: 20px; border: 2px solid #667eea;">
                    <h4 style="color: #667eea; font-size: 18px; margin-bottom: 15px;">‚≠ê Eval√∫a al Equipo:</h4>
                    <p style="color: #666; margin-bottom: 15px;" id="evaluatedTeamName">Eval√∫a la presentaci√≥n del equipo</p>
                    
                    <form id="evaluationForm" onsubmit="submitEvaluation(event)">
                        <div class="form-group">
                            <label>Claridad del Problema (1-10)</label>
                            <input type="number" id="clarityScore" min="1" max="10" value="5" required style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px; margin-top: 5px;">
                        </div>

                        <div class="form-group">
                            <label>Calidad de la Soluci√≥n (1-10)</label>
                            <input type="number" id="solutionScore" min="1" max="10" value="5" required style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px; margin-top: 5px;">
                        </div>

                        <div class="form-group">
                            <label>Presentaci√≥n y Comunicaci√≥n (1-10)</label>
                            <input type="number" id="presentationScore" min="1" max="10" value="5" required style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px; margin-top: 5px;">
                        </div>

                        <div class="form-group">
                            <label>Feedback (opcional)</label>
                            <textarea id="evaluationFeedback" rows="3" placeholder="Escribe tu feedback aqu√≠..." style="width: 100%; padding: 10px; border: 1px solid #ddd; border-radius: 8px; margin-top: 5px;"></textarea>
                        </div>

                        <button type="submit" class="submit-btn" id="submitEvaluationBtn">
                            ‚úì Enviar Evaluaci√≥n
                        </button>
                    </form>
                </div>
            </div>
        </div>

        <!-- Mensaje de espera -->
        <div class="waiting-message" id="waitingMessage" style="display: none;">
            <div class="waiting-icon">‚è≥</div>
            <p class="waiting-text">Esperando a que el profesor inicie la siguiente actividad...</p>
        </div>

        <!-- Resultados de Etapa -->
        <div class="activity-card" id="resultsActivity" style="display: none;">
            <div class="activity-header">
                <h2>üèÜ Resultados de la Etapa</h2>
            </div>
            <div class="activity-content">
                <div class="stage-info-box">
                    <div class="stage-icon-large" id="resultsStageIcon">üë•</div>
                    <h3 id="resultsStageTitle">Etapa 1: Trabajo en Equipo</h3>
                    <p id="resultsStageDescription">Resultados finales de la etapa</p>
                </div>

                <div class="results-summary" id="resultsSummary">
                    <!-- Los resultados se cargar√°n aqu√≠ -->
                </div>

                <div class="waiting-next-stage" id="waitingNextStage" style="display: none;">
                    <div class="waiting-icon">‚è≥</div>
                    <p class="waiting-text" id="waitingNextStageText">Esperando a que el profesor inicie la siguiente etapa...</p>
                </div>
            </div>
        </div>

        <div class="loading" id="loading">
            <div class="loading-spinner"></div>
            <p>Cargando...</p>
        </div>
    </div>

    <script>
        const API_BASE_URL = 'http://localhost:8000/api';
        
        // Obtener connection_id de la URL o localStorage
        const urlParams = new URLSearchParams(window.location.search);
        let connectionId = urlParams.get('connection_id') || localStorage.getItem('tabletConnectionId');
        
        if (!connectionId) {
            window.location.href = '/tablet/join/';
        }

        let myTeamId = null;
        let currentStage = null;
        let currentActivity = null;
        let knowEachOther = null;

        // Funci√≥n para obtener colores hex desde nombres
        function getTeamColorHex(color) {
            const colorMap = {
                'Verde': '#28a745',
                'Azul': '#007bff',
                'Rojo': '#dc3545',
                'Amarillo': '#ffc107',
                'Naranja': '#fd7e14',
                'Morado': '#6f42c1',
                'Rosa': '#e83e8c',
                'Cian': '#17a2b8',
                'Gris': '#6c757d',
                'Marr√≥n': '#795548'
            };
            return colorMap[color] || '#667eea';
        }

        function showAlert(message, type = 'info') {
            const alertContainer = document.getElementById('alertContainer');
            const alert = document.createElement('div');
            alert.className = `alert alert-${type} show`;
            alert.textContent = message;
            alertContainer.innerHTML = '';
            alertContainer.appendChild(alert);
            
            setTimeout(() => {
                alert.classList.remove('show');
            }, 5000);
        }

        async function loadGameState() {
            try {
                const statusResponse = await fetch(`${API_BASE_URL}/sessions/tablet-connections/status/?connection_id=${connectionId}`);
                
                if (!statusResponse.ok) {
                    if (statusResponse.status === 404) {
                        showAlert('Conexi√≥n no encontrada. Por favor reconecta.', 'error');
                        setTimeout(() => {
                            window.location.href = '/tablet/join/';
                        }, 3000);
                    }
                    return;
                }

                const statusData = await statusResponse.json();
                myTeamId = statusData.team.id;
                
                // Actualizar header
                const team = statusData.team;
                document.getElementById('teamName').textContent = team.name;
                document.getElementById('teamInfo').textContent = `Equipo ${team.color}`;
                document.getElementById('teamColor').textContent = team.color.charAt(0).toUpperCase();
                document.getElementById('teamColor').style.background = getTeamColorHex(team.color);
                document.getElementById('tokensCount').textContent = team.tokens_total || 0;

                // Obtener estado del juego (sin autenticaci√≥n)
                const gameSessionId = statusData.game_session.id;
                const gameResponse = await fetch(`${API_BASE_URL}/sessions/game-sessions/${gameSessionId}/`);
                
                if (!gameResponse.ok) {
                    showAlert('Error al cargar el estado del juego', 'error');
                    return;
                }

                const gameData = await gameResponse.json();
                
                // Si el juego no est√° corriendo, volver al lobby
                if (gameData.status !== 'running') {
                    window.location.href = `/tablet/lobby/?connection_id=${connectionId}`;
                    return;
                }

                // Mostrar modal de explicaci√≥n de etapa si es la primera vez
                const currentStageNumber = gameData.current_stage_number || 1;
                const stageModalKey = `stage_${currentStageNumber}_shown`;
                const stageModalShown = sessionStorage.getItem(stageModalKey);
                if (!stageModalShown && gameData.current_stage) {
                    // Actualizar contenido del modal seg√∫n la etapa
                    if (currentStageNumber === 1) {
                        document.getElementById('stageIcon').textContent = 'üë•';
                        document.getElementById('stageTitle').textContent = 'Etapa 1: Trabajo en Equipo';
                        document.getElementById('stageObjective').textContent = 'Conocerse o fortalecer compa√±erismo';
                        document.getElementById('stageDescription').textContent = 'En esta etapa, trabajar√°s junto a tu equipo para conoceros mejor y fortalecer vuestro v√≠nculo. Realizar√°s actividades que te ayudar√°n a entender mejor a tus compa√±eros y a trabajar juntos de manera m√°s efectiva.';
                    } else if (currentStageNumber === 2) {
                        document.getElementById('stageIcon').textContent = 'üí≠';
                        document.getElementById('stageTitle').textContent = 'Etapa 2: Empat√≠a';
                        document.getElementById('stageObjective').textContent = 'Conocer problemas y abordar un caso o desaf√≠o';
                        document.getElementById('stageDescription').textContent = 'En esta etapa, explorar√°s un tema de inter√©s relacionado con tu facultad, analizar√°s un desaf√≠o espec√≠fico y crear√°s un mapa mental con ideas y conceptos para entender mejor el problema.';
                    } else if (currentStageNumber === 3) {
                        document.getElementById('stageIcon').textContent = 'üß±';
                        document.getElementById('stageTitle').textContent = 'Etapa 3: Creatividad';
                        document.getElementById('stageObjective').textContent = 'Crear una soluci√≥n con legos';
                        document.getElementById('stageDescription').textContent = 'En esta etapa, construir√°s f√≠sicamente un prototipo con legos que represente tu soluci√≥n al problema identificado.';
                    } else if (currentStageNumber === 4) {
                        document.getElementById('stageIcon').textContent = 'üì¢';
                        document.getElementById('stageTitle').textContent = 'Etapa 4: Comunicaci√≥n';
                        document.getElementById('stageObjective').textContent = 'Crear y comunicar pitch';
                        document.getElementById('stageDescription').textContent = 'En esta etapa, crear√°s y presentar√°s tu pitch. Primero completar√°s un formulario estructurado y luego presentar√°s tu pitch ante los dem√°s equipos.';
                    }
                    showStageModal();
                    sessionStorage.setItem(stageModalKey, 'true');
                }

                // Determinar qu√© actividad mostrar bas√°ndose en la actividad actual de la sesi√≥n
                currentActivityId = gameData.current_activity; // Guardar en variable global
                const currentActivityName = gameData.current_activity_name;
                // currentStageNumber ya fue declarado arriba
                
                console.log('üìã Actividad actual:', {
                    id: currentActivityId,
                    name: currentActivityName,
                    stage_number: currentStageNumber,
                    type: typeof currentActivityName
                });
                
                // Si no hay actividad actual, significa que la etapa est√° completada - mostrar resultados
                if (!currentActivityName || !currentActivityId) {
                    console.log('‚ö†Ô∏è No hay actividad actual, mostrando resultados...');
                    showActivity('results');
                    await loadStageResults(statusData.game_session.id, gameData.current_stage);
                    // Actualizar mensaje de espera seg√∫n la etapa actual
                    const nextStageNumber = currentStageNumber + 1;
                    const waitingText = document.getElementById('waitingNextStageText');
                    if (waitingText && nextStageNumber <= 4) {
                        waitingText.textContent = `Esperando a que el profesor inicie la Etapa ${nextStageNumber}...`;
                    }
                    document.getElementById('waitingNextStage').style.display = 'block';
                    document.getElementById('loading').classList.remove('show');
                    return;
                }
                
                // Normalizar el nombre de la actividad para comparaciones
                const normalizedActivityName = currentActivityName.toLowerCase().trim();
                console.log('üîç Nombre de actividad normalizado:', normalizedActivityName);
                
                // Verificar si el equipo se conoce
                const teamKnowsEachOther = statusData.personalization?.team_members_know_each_other;
                
                if (currentActivityName === 'Personalizaci√≥n') {
                    showActivity('personalization');
                    // NOTA: No necesitamos session_stage para personalizaci√≥n, solo team_id, team_name y team_members_know_each_other
                    // Iniciar temporizador si no est√° iniciado
                    // Verificar espec√≠ficamente para personalizaci√≥n, no usar timerStartTime global
                    const personalizationTimerStart = sessionStorage.getItem(`timerStartTime_${connectionId}_${currentActivityId}`);
                    if (!timerIntervalPersonalization && !personalizationTimerStart) {
                        await startTimer(currentActivityId, 'personalization', statusData.game_session.id);
                    } else if (personalizationTimerStart && !timerIntervalPersonalization) {
                        // Si existe en sessionStorage pero el intervalo no est√° corriendo, restaurar
                        await startTimer(currentActivityId, 'personalization', statusData.game_session.id);
                    }
                    checkExistingPersonalization(myTeamId);
                } else if (currentActivityName === 'Presentaci√≥n') {
                    // Si el equipo se conoce ‚Üí minijuego de anagramas
                    // Si el equipo NO se conoce ‚Üí actividad de presentaci√≥n (hablar)
                    if (teamKnowsEachOther === true) {
                        showActivity('anagram');
                        // Asegurar que currentSessionStageId est√© definido ANTES de cargar la actividad
                        if (!currentSessionStageId) {
                            console.log('üîç Obteniendo session_stage para anagrama...');
                            const stagesResponse = await fetch(`${API_BASE_URL}/sessions/session-stages/?game_session=${statusData.game_session.id}`);
                            if (stagesResponse.ok) {
                                const stagesData = await stagesResponse.json();
                                const stages = stagesData.results || stagesData;
                                if (stages.length > 0) {
                                    currentSessionStageId = stages[0].id;
                                    console.log('‚úÖ currentSessionStageId obtenido:', currentSessionStageId);
                                } else {
                                    console.warn('‚ö†Ô∏è No se encontraron session_stages');
                                }
                            } else {
                                console.error('‚ùå Error al obtener session_stages:', stagesResponse.status, stagesResponse.statusText);
                            }
                        }
                        // Solo cargar si no est√° ya cargado
                        if (!anagramWords.length || currentAnagramIndex === 0) {
                            await loadAnagramActivity(currentActivityId, gameData.current_stage, statusData.game_session.id);
                        }
                        // Iniciar temporizador si no est√° iniciado (y no est√° ya corriendo)
                        // Verificar espec√≠ficamente para anagrama, no usar timerStartTime global
                        const anagramTimerStart = sessionStorage.getItem(`timerStartTime_${connectionId}_${currentActivityId}`);
                        if (!timerInterval && !anagramTimerStart) {
                            await startTimer(currentActivityId, 'anagram', statusData.game_session.id);
                        } else if (anagramTimerStart && !timerInterval) {
                            // Si existe en sessionStorage pero el intervalo no est√° corriendo, restaurar
                            await startTimer(currentActivityId, 'anagram', statusData.game_session.id);
                        }
                        // Verificar progreso existente
                        checkExistingAnagramProgress(myTeamId, currentActivityId);
                    } else if (teamKnowsEachOther === false) {
                        showActivity('presentation');
                        // Asegurar que currentSessionStageId est√© definido ANTES de iniciar el temporizador
                        if (!currentSessionStageId) {
                            console.log('üîç Obteniendo session_stage para presentaci√≥n...');
                            const stagesResponse = await fetch(`${API_BASE_URL}/sessions/session-stages/?game_session=${statusData.game_session.id}`);
                            if (stagesResponse.ok) {
                                const stagesData = await stagesResponse.json();
                                const stages = stagesData.results || stagesData;
                                if (stages.length > 0) {
                                    currentSessionStageId = stages[0].id;
                                    console.log('‚úÖ currentSessionStageId obtenido para presentaci√≥n:', currentSessionStageId);
                                } else {
                                    console.warn('‚ö†Ô∏è No se encontraron session_stages para presentaci√≥n');
                                }
                            } else {
                                console.error('‚ùå Error al obtener session_stages para presentaci√≥n:', stagesResponse.status, stagesResponse.statusText);
                                const errorData = await stagesResponse.json().catch(() => ({}));
                                console.error('   Detalles del error:', errorData);
                            }
                        } else {
                            console.log('‚úÖ currentSessionStageId ya est√° definido para presentaci√≥n:', currentSessionStageId);
                        }
                        // Iniciar temporizador si no est√° iniciado (y no est√° ya corriendo)
                        // Verificar espec√≠ficamente para presentaci√≥n, no usar timerStartTime global
                        const presentationTimerStart = sessionStorage.getItem(`timerStartTime_${connectionId}_${currentActivityId}`);
                        if (!timerIntervalPresentation && !presentationTimerStart) {
                            await startTimer(currentActivityId, 'presentation', statusData.game_session.id);
                        } else if (presentationTimerStart && !timerIntervalPresentation) {
                            // Si existe en sessionStorage pero el intervalo no est√° corriendo, restaurar
                            await startTimer(currentActivityId, 'presentation', statusData.game_session.id);
                        }
                        checkExistingPresentationProgress(myTeamId, currentActivityId);
                    } else {
                        // Si a√∫n no se ha definido, mostrar mensaje de espera
                        document.getElementById('waitingMessage').style.display = 'block';
                    }
                } else if (currentActivityName && (
                    currentActivityName.toLowerCase().includes('tema') || 
                    currentActivityName.toLowerCase().includes('seleccionar')
                )) {
                    // Actividad de selecci√≥n de tema (Etapa 2)
                    showActivity('topic_selection');
                    // Obtener session_stage para Etapa 2 (SIEMPRE obtenerlo para asegurar que sea el correcto)
                    console.log('üîç Obteniendo session_stage para Etapa 2 (Selecci√≥n de Tema)...');
                    const stagesResponse = await fetch(`${API_BASE_URL}/sessions/session-stages/?game_session=${statusData.game_session.id}`);
                    if (stagesResponse.ok) {
                        const stagesData = await stagesResponse.json();
                        const stages = stagesData.results || stagesData;
                        const stage2 = stages.find(s => s.stage_number === 2);
                        if (stage2) {
                            currentSessionStageId = stage2.id;
                            console.log('‚úÖ currentSessionStageId actualizado para Etapa 2:', currentSessionStageId);
                        } else {
                            console.error('‚ùå No se encontr√≥ session_stage para Etapa 2');
                        }
                    } else {
                        console.error('‚ùå Error al obtener session_stages:', stagesResponse.status);
                    }
                    // Iniciar temporizador
                    const topicTimerStart = sessionStorage.getItem(`timerStartTime_${connectionId}_${currentActivityId}`);
                    if (!topicTimerInterval && !topicTimerStart) {
                        await startTimer(currentActivityId, 'topic', statusData.game_session.id);
                    } else if (topicTimerStart && !topicTimerInterval) {
                        await startTimer(currentActivityId, 'topic', statusData.game_session.id);
                    }
                    await loadTopicsForSelection(statusData.game_session.id);
                } else if (currentActivityName && (
                    currentActivityName.toLowerCase().includes('desaf√≠o') || 
                    currentActivityName.toLowerCase().includes('desafio') ||
                    currentActivityName.toLowerCase().includes('ver el')
                )) {
                    // Actividad de ver desaf√≠o (Etapa 2)
                    showActivity('challenge_view');
                    // Obtener session_stage para Etapa 2
                    if (!currentSessionStageId) {
                        const stagesResponse = await fetch(`${API_BASE_URL}/sessions/session-stages/?game_session=${statusData.game_session.id}`);
                        if (stagesResponse.ok) {
                            const stagesData = await stagesResponse.json();
                            const stages = stagesData.results || stagesData;
                            const stage2 = stages.find(s => s.stage_number === 2);
                            if (stage2) {
                                currentSessionStageId = stage2.id;
                            }
                        }
                    }
                    // Iniciar temporizador
                    const challengeTimerStart = sessionStorage.getItem(`timerStartTime_${connectionId}_${currentActivityId}`);
                    if (!challengeTimerInterval && !challengeTimerStart) {
                        await startTimer(currentActivityId, 'challenge', statusData.game_session.id);
                    } else if (challengeTimerStart && !challengeTimerInterval) {
                        await startTimer(currentActivityId, 'challenge', statusData.game_session.id);
                    }
                    await loadChallengeForView(statusData.game_session.id);
                } else if (currentActivityName && currentActivityName.toLowerCase().includes('bubble')) {
                    // Actividad de bubble map (Etapa 2)
                    showActivity('bubble_map');
                    // Obtener session_stage para Etapa 2
                    if (!currentSessionStageId) {
                        const stagesResponse = await fetch(`${API_BASE_URL}/sessions/session-stages/?game_session=${statusData.game_session.id}`);
                        if (stagesResponse.ok) {
                            const stagesData = await stagesResponse.json();
                            const stages = stagesData.results || stagesData;
                            const stage2 = stages.find(s => s.stage_number === 2);
                            if (stage2) {
                                currentSessionStageId = stage2.id;
                            }
                        }
                    }
                    // Iniciar temporizador
                    const bubbleMapTimerStart = sessionStorage.getItem(`timerStartTime_${connectionId}_${currentActivityId}`);
                    if (!bubbleMapTimerInterval && !bubbleMapTimerStart) {
                        await startTimer(currentActivityId, 'bubble_map', statusData.game_session.id);
                    } else if (bubbleMapTimerStart && !bubbleMapTimerInterval) {
                        await startTimer(currentActivityId, 'bubble_map', statusData.game_session.id);
                    }
                    await loadBubbleMapForEdit(statusData.game_session.id);
                } else if (currentActivityName && (
                    currentActivityName.toLowerCase().includes('prototipo') || 
                    currentActivityName.toLowerCase().includes('lego') ||
                    currentActivityName.toLowerCase().includes('subida')
                )) {
                    // Actividad de subida de prototipo (Etapa 3)
                    console.log('‚úÖ Mostrando actividad de prototipo:', currentActivityName);
                    console.log('   - Etapa actual:', currentStageNumber);
                    console.log('   - Activity ID:', currentActivityId);
                    showActivity('prototype_upload');
                    // Ocultar mensaje de espera
                    document.getElementById('waitingMessage').style.display = 'none';
                    // SIEMPRE obtener session_stage para Etapa 3 (para asegurar que tenemos el correcto)
                    console.log('üîç Obteniendo session_stage para Etapa 3...');
                    const stagesResponse = await fetch(`${API_BASE_URL}/sessions/session-stages/?game_session=${statusData.game_session.id}`);
                    if (stagesResponse.ok) {
                        const stagesData = await stagesResponse.json();
                        const stages = stagesData.results || stagesData;
                        const stage3 = stages.find(s => s.stage_number === 3);
                        if (stage3) {
                            currentSessionStageId = stage3.id;
                            console.log('‚úÖ currentSessionStageId para Etapa 3 actualizado:', currentSessionStageId);
                            console.log('   - Stage ID:', stage3.stage);
                            console.log('   - Stage Number:', stage3.stage_number);
                        } else {
                            console.error('‚ùå No se encontr√≥ session_stage para Etapa 3');
                            console.error('   - Stages disponibles:', stages.map(s => ({ id: s.id, stage_number: s.stage_number })));
                        }
                    } else {
                        console.error('‚ùå Error al obtener session_stages:', stagesResponse.status);
                    }
                    // Iniciar temporizador
                    const prototypeTimerStart = sessionStorage.getItem(`timerStartTime_${connectionId}_${currentActivityId}`);
                    if (!prototypeTimerInterval && !prototypeTimerStart) {
                        await startTimer(currentActivityId, 'prototype', statusData.game_session.id);
                    } else if (prototypeTimerStart && !prototypeTimerInterval) {
                        await startTimer(currentActivityId, 'prototype', statusData.game_session.id);
                    }
                    await loadPrototypeStatus(statusData.game_session.id);
                } else if (normalizedActivityName && (
                    (normalizedActivityName.includes('pitch') && normalizedActivityName.includes('formulario')) ||
                    (normalizedActivityName.includes('formulario') && normalizedActivityName.includes('pitch'))
                )) {
                    // Actividad de formulario de pitch (Etapa 4)
                    console.log('‚úÖ Mostrando actividad de formulario de pitch:', currentActivityName);
                    console.log('   - Nombre normalizado:', normalizedActivityName);
                    console.log('   - Etapa actual:', currentStageNumber);
                    console.log('   - Activity ID:', currentActivityId);
                    showActivity('pitch_form');
                    // Ocultar mensaje de espera
                    document.getElementById('waitingMessage').style.display = 'none';
                    // Obtener session_stage para Etapa 4
                    console.log('üîç Obteniendo session_stage para Etapa 4...');
                    const stagesResponse = await fetch(`${API_BASE_URL}/sessions/session-stages/?game_session=${statusData.game_session.id}`);
                    if (stagesResponse.ok) {
                        const stagesData = await stagesResponse.json();
                        const stages = stagesData.results || stagesData;
                        const stage4 = stages.find(s => s.stage_number === 4);
                        if (stage4) {
                            currentSessionStageId = stage4.id;
                            console.log('‚úÖ currentSessionStageId para Etapa 4 actualizado:', currentSessionStageId);
                        } else {
                            console.error('‚ùå No se encontr√≥ session_stage para Etapa 4');
                        }
                    } else {
                        console.error('‚ùå Error al obtener session_stages:', stagesResponse.status);
                    }
                    // Iniciar temporizador
                    const pitchTimerStart = sessionStorage.getItem(`timerStartTime_${connectionId}_${currentActivityId}`);
                    if (!pitchTimerInterval && !pitchTimerStart) {
                        await startTimer(currentActivityId, 'pitch', statusData.game_session.id);
                    } else if (pitchTimerStart && !pitchTimerInterval) {
                        await startTimer(currentActivityId, 'pitch', statusData.game_session.id);
                    }
                    await loadExistingPitch(statusData.game_session.id);
                } else if (normalizedActivityName && (
                    (normalizedActivityName.includes('pitch') && normalizedActivityName.includes('presentacion')) ||
                    (normalizedActivityName.includes('presentaci√≥n') && normalizedActivityName.includes('pitch')) ||
                    (normalizedActivityName.includes('presentacion') && !normalizedActivityName.includes('formulario'))
                )) {
                    // Actividad de presentaci√≥n del pitch (Etapa 4)
                    console.log('‚úÖ Mostrando actividad de presentaci√≥n del pitch:', currentActivityName);
                    console.log('   - Etapa actual:', currentStageNumber);
                    console.log('   - Activity ID:', currentActivityId);
                    console.log('   - Nombre normalizado:', normalizedActivityName);
                    showActivity('pitch_presentation');
                    // Ocultar mensaje de espera
                    document.getElementById('waitingMessage').style.display = 'none';
                    // Obtener session_stage para Etapa 4
                    console.log('üîç Obteniendo session_stage para Etapa 4...');
                    const stagesResponse = await fetch(`${API_BASE_URL}/sessions/session-stages/?game_session=${statusData.game_session.id}`);
                    if (stagesResponse.ok) {
                        const stagesData = await stagesResponse.json();
                        const stages = stagesData.results || stagesData;
                        const stage4 = stages.find(s => s.stage_number === 4);
                        if (stage4) {
                            currentSessionStageId = stage4.id;
                            console.log('‚úÖ currentSessionStageId para Etapa 4 actualizado:', currentSessionStageId);
                        } else {
                            console.error('‚ùå No se encontr√≥ session_stage para Etapa 4');
                        }
                    } else {
                        console.error('‚ùå Error al obtener session_stages:', stagesResponse.status);
                    }
                    // Iniciar temporizador si es su turno
                    await loadPresentationStatus(statusData.game_session.id);
                } else if (currentStageNumber === 4 && !currentActivityName) {
                    // Si estamos en Etapa 4 pero no hay actividad, puede que el profesor est√© configurando el orden
                    // Verificar si hay una actividad de presentaci√≥n pendiente
                    try {
                        const stagesResponse = await fetch(`${API_BASE_URL}/sessions/session-stages/?game_session=${statusData.game_session.id}`);
                        if (stagesResponse.ok) {
                            const stagesData = await stagesResponse.json();
                            const stages = stagesData.results || stagesData;
                            const stage4 = stages.find(s => s.stage_number === 4);
                            if (stage4) {
                                currentSessionStageId = stage4.id;
                                // Verificar si hay orden de presentaci√≥n configurado
                                const statusResponse = await fetch(`${API_BASE_URL}/sessions/session-stages/${currentSessionStageId}/presentation_status/`);
                                if (statusResponse.ok) {
                                    const statusData = await statusResponse.json();
                                    if (statusData.presentation_order && statusData.presentation_order.length > 0) {
                                        // Hay orden configurado, mostrar actividad de presentaci√≥n
                                        console.log('‚úÖ Orden de presentaci√≥n detectado, mostrando actividad de presentaci√≥n...');
                                        showActivity('pitch_presentation');
                                        document.getElementById('waitingMessage').style.display = 'none';
                                        await loadPresentationStatus(statusData.game_session.id);
                                    } else {
                                        document.getElementById('waitingMessage').style.display = 'block';
                                    }
                                } else {
                                    document.getElementById('waitingMessage').style.display = 'block';
                                }
                            } else {
                                document.getElementById('waitingMessage').style.display = 'block';
                            }
                        } else {
                            document.getElementById('waitingMessage').style.display = 'block';
                        }
                    } catch (error) {
                        console.error('Error verificando orden de presentaci√≥n:', error);
                        document.getElementById('waitingMessage').style.display = 'block';
                    }
                } else {
                    // Actividad desconocida o no iniciada
                    document.getElementById('waitingMessage').style.display = 'block';
                }

                document.getElementById('loading').classList.remove('show');
            } catch (error) {
                console.error('Error loading game state:', error);
                // Manejar errores de JSON parse espec√≠ficamente
                if (error.message && (error.message.includes('JSON.parse') || error.message.includes('Unexpected token') || error.message.includes('JSON'))) {
                    showAlert('Error de conexi√≥n: El servidor devolvi√≥ una respuesta no v√°lida. Por favor, recarga la p√°gina.', 'error');
                } else {
                    showAlert('Error de conexi√≥n: ' + error.message, 'error');
                }
            }
        }

        function showStageModal() {
            const modal = document.getElementById('stageModal');
            modal.classList.add('show');
        }

        function closeStageModal() {
            const modal = document.getElementById('stageModal');
            modal.classList.remove('show');
        }

        function showActivity(activityId) {
            console.log('üéØ showActivity llamado con:', activityId);
            // Ocultar todas las actividades
            document.getElementById('personalizationActivity').classList.remove('active');
            document.getElementById('anagramActivity').classList.remove('active');
            document.getElementById('presentationActivity').classList.remove('active');
            document.getElementById('topicSelectionActivity').classList.remove('active');
            document.getElementById('challengeViewActivity').classList.remove('active');
            document.getElementById('bubbleMapActivity').classList.remove('active');
            document.getElementById('prototypeUploadActivity').classList.remove('active');
            document.getElementById('pitchFormActivity').classList.remove('active');
            document.getElementById('pitchPresentationActivity').classList.remove('active');
            document.getElementById('resultsActivity').style.display = 'none';
            document.getElementById('waitingMessage').style.display = 'none';
            
            // Mostrar la actividad correspondiente
            if (activityId === 1 || activityId === 'personalization') {
                document.getElementById('personalizationActivity').classList.add('active');
                console.log('‚úÖ Mostrando actividad: Personalizaci√≥n');
            } else if (activityId === 2 || activityId === 'anagram') {
                document.getElementById('anagramActivity').classList.add('active');
                console.log('‚úÖ Mostrando actividad: Anagrama');
            } else if (activityId === 'presentation') {
                document.getElementById('presentationActivity').classList.add('active');
                console.log('‚úÖ Mostrando actividad: Presentaci√≥n');
            } else if (activityId === 'topic_selection' || activityId === 'seleccionar_tema') {
                document.getElementById('topicSelectionActivity').classList.add('active');
                console.log('‚úÖ Mostrando actividad: Selecci√≥n de Tema');
            } else if (activityId === 'challenge_view' || activityId === 'ver_desafio') {
                document.getElementById('challengeViewActivity').classList.add('active');
                console.log('‚úÖ Mostrando actividad: Ver Desaf√≠o');
            } else if (activityId === 'bubble_map') {
                document.getElementById('bubbleMapActivity').classList.add('active');
                console.log('‚úÖ Mostrando actividad: Bubble Map');
            } else if (activityId === 'prototype_upload' || activityId === 'prototype') {
                const prototypeElement = document.getElementById('prototypeUploadActivity');
                if (prototypeElement) {
                    prototypeElement.classList.add('active');
                    console.log('‚úÖ Mostrando actividad: Prototipo Upload');
                } else {
                    console.error('‚ùå No se encontr√≥ el elemento prototypeUploadActivity');
                }
            } else if (activityId === 'pitch_form' || activityId === 'formulario_pitch' || activityId === 'formulario de pitch') {
                document.getElementById('pitchFormActivity').classList.add('active');
                console.log('‚úÖ Mostrando actividad: Formulario de Pitch');
            } else if (activityId === 'pitch_presentation' || activityId === 'presentacion_pitch' || activityId === 'presentacion de pitch') {
                document.getElementById('pitchPresentationActivity').classList.add('active');
                console.log('‚úÖ Mostrando actividad: Presentaci√≥n del Pitch');
            } else if (activityId === 'results') {
                document.getElementById('resultsActivity').style.display = 'block';
                console.log('‚úÖ Mostrando actividad: Resultados');
            } else {
                document.getElementById('waitingMessage').style.display = 'block';
                console.warn('‚ö†Ô∏è Actividad desconocida:', activityId);
            }
        }

        async function loadStageResults(gameSessionId, stageId) {
            try {
                let resultsUrl = `${API_BASE_URL}/sessions/game-sessions/${gameSessionId}/stage_results/`;
                if (stageId) {
                    resultsUrl += `?stage_id=${stageId}`;
                }

                const response = await fetch(resultsUrl);
                if (!response.ok) {
                    throw new Error('Error al cargar resultados');
                }

                const resultsData = await response.json();
                renderStageResults(resultsData);
            } catch (error) {
                console.error('Error cargando resultados:', error);
                showAlert('Error al cargar resultados: ' + error.message, 'error');
            }
        }

        function renderStageResults(data) {
            // Actualizar t√≠tulo de etapa
            document.getElementById('resultsStageTitle').textContent = `Etapa ${data.stage_number}: ${data.stage_name}`;

            // Buscar nuestro equipo en los resultados
            const myTeamResult = data.teams_results.find(team => team.team_id === myTeamId);
            const myRank = data.teams_results.findIndex(team => team.team_id === myTeamId) + 1;

            if (!myTeamResult) {
                document.getElementById('resultsSummary').innerHTML = '<p style="text-align: center; color: #666;">No se encontraron resultados para tu equipo.</p>';
                return;
            }

            // Renderizar resultados del equipo
            const medal = myRank === 1 ? 'ü•á' : myRank === 2 ? 'ü•à' : myRank === 3 ? 'ü•â' : `${myRank}¬∞`;
            
            // Funci√≥n para obtener color del equipo
            const getTeamColorHex = (color) => {
                const colorMap = {
                    'Verde': '#28a745',
                    'Azul': '#007bff',
                    'Rojo': '#dc3545',
                    'Amarillo': '#ffc107',
                    'Naranja': '#fd7e14',
                    'Morado': '#6f42c1',
                    'Rosa': '#e83e8c',
                    'Cian': '#17a2b8',
                    'Gris': '#6c757d',
                    'Marr√≥n': '#795548'
                };
                return colorMap[color] || '#667eea';
            };
            
            document.getElementById('resultsSummary').innerHTML = `
                <div style="background: white; border-radius: 15px; padding: 30px; box-shadow: 0 5px 15px rgba(0, 0, 0, 0.1);">
                    <!-- Posici√≥n del equipo -->
                    <div style="text-align: center; margin-bottom: 25px;">
                        <div style="font-size: 60px; margin-bottom: 15px;">${medal}</div>
                        <h3 style="color: #333; font-size: 24px; margin-bottom: 10px;">Tu posici√≥n: ${myRank}¬∞ lugar</h3>
                    </div>
                    
                    <!-- Tokens del equipo -->
                    <div style="display: flex; justify-content: space-around; margin: 30px 0; padding: 20px; background: #f8f9fa; border-radius: 12px;">
                        <div style="text-align: center;">
                            <div style="color: #666; font-size: 14px; margin-bottom: 8px;">Tokens en esta etapa</div>
                            <div style="font-size: 32px; font-weight: 700; color: #667eea;">+${myTeamResult.tokens_stage}</div>
                        </div>
                        <div style="text-align: center;">
                            <div style="color: #666; font-size: 14px; margin-bottom: 8px;">Tokens totales</div>
                            <div style="font-size: 32px; font-weight: 700; color: #28a745;">${myTeamResult.tokens_total}</div>
                        </div>
                    </div>

                    <!-- Ranking de todos los equipos -->
                    <div style="margin-top: 30px; padding-top: 25px; border-top: 2px solid #e9ecef;">
                        <h4 style="color: #333; font-size: 18px; margin-bottom: 15px; text-align: center;">üìä Clasificaci√≥n General</h4>
                        <div style="display: flex; flex-direction: column; gap: 10px;">
                            ${data.teams_results.map((team, index) => {
                                const rank = index + 1;
                                const rankMedal = rank === 1 ? 'ü•á' : rank === 2 ? 'ü•à' : rank === 3 ? 'ü•â' : `${rank}¬∞`;
                                const isMyTeam = team.team_id === myTeamId;
                                const bgColor = isMyTeam ? '#e7f3ff' : '#f8f9fa';
                                const borderColor = isMyTeam ? '#2196F3' : 'transparent';
                                return `
                                    <div style="display: flex; align-items: center; padding: 15px; background: ${bgColor}; border-radius: 10px; border-left: 4px solid ${borderColor}; ${isMyTeam ? 'border: 2px solid #2196F3;' : ''}">
                                        <div style="font-size: 24px; margin-right: 15px; min-width: 40px; text-align: center;">${rankMedal}</div>
                                        <div style="flex: 1;">
                                            <div style="display: flex; align-items: center; margin-bottom: 5px;">
                                                <div style="width: 20px; height: 20px; border-radius: 50%; background: ${getTeamColorHex(team.team_color)}; margin-right: 10px;"></div>
                                                <span style="font-weight: ${isMyTeam ? '700' : '600'}; color: #333; font-size: ${isMyTeam ? '16px' : '14px'};">
                                                    ${team.team_name} ${isMyTeam ? '(Tu equipo)' : ''}
                                                </span>
                                            </div>
                                            <div style="display: flex; gap: 20px; font-size: 12px; color: #666;">
                                                <span>Etapa: <strong>${team.tokens_stage}</strong> tokens</span>
                                                <span>Total: <strong>${team.tokens_total}</strong> tokens</span>
                                            </div>
                                        </div>
                                    </div>
                                `;
                            }).join('')}
                        </div>
                    </div>

                    <!-- Actividades completadas del equipo -->
                    <div style="margin-top: 25px; padding-top: 25px; border-top: 2px solid #e9ecef;">
                        <h4 style="color: #333; font-size: 18px; margin-bottom: 15px;">Actividades completadas:</h4>
                        ${myTeamResult.activities_progress.map(activity => `
                            <div style="display: flex; justify-content: space-between; align-items: center; padding: 12px; margin-bottom: 10px; background: #f8f9fa; border-radius: 8px;">
                                <span style="color: #333; font-size: 14px;">${activity.activity_name}</span>
                                <span style="padding: 5px 12px; border-radius: 15px; font-size: 12px; font-weight: 600; background: ${activity.status === 'completed' ? '#d4edda' : '#fff3cd'}; color: ${activity.status === 'completed' ? '#155724' : '#856404'};">
                                    ${activity.status === 'completed' ? '‚úì Completada' : '‚è≥ Pendiente'}
                                </span>
                            </div>
                        `).join('')}
                    </div>
                </div>
            `;
        }

        async function checkExistingPersonalization(teamId) {
            try {
                // Intentar obtener personalizaci√≥n existente
                const response = await fetch(`${API_BASE_URL}/sessions/team-personalizations/?team=${teamId}`);
                
                if (response.ok) {
                    const data = await response.json();
                    const results = data.results || data;
                    
                    if (results.length > 0) {
                        const personalization = results[0];
                        
                        // Pre-llenar formulario si ya existe
                        if (personalization.team_name) {
                            document.getElementById('teamNameInput').value = personalization.team_name;
                        }
                        
                        if (personalization.team_members_know_each_other !== null) {
                            selectKnowOption(personalization.team_members_know_each_other);
                        }
                        
                        // Si ya est√° completo, deshabilitar formulario
                        if (personalization.team_name && personalization.team_members_know_each_other !== null) {
                            document.getElementById('teamNameInput').disabled = true;
                            document.getElementById('knowYesBtn').disabled = true;
                            document.getElementById('knowNoBtn').disabled = true;
                            document.getElementById('submitBtn').textContent = '‚úì Entregado';
                            document.getElementById('submitBtn').disabled = true;
                        }
                    }
                }
            } catch (error) {
                console.error('Error checking personalization:', error);
            }
        }

        function selectKnowOption(value) {
            knowEachOther = value;
            
            // Actualizar botones
            document.getElementById('knowYesBtn').classList.toggle('selected', value === true);
            document.getElementById('knowNoBtn').classList.toggle('selected', value === false);
        }

        async function handlePersonalizationSubmit(event) {
            event.preventDefault();
            
            const teamName = document.getElementById('teamNameInput').value.trim();
            
            if (!teamName) {
                showAlert('Por favor ingresa un nombre para el equipo', 'error');
                return;
            }

            if (knowEachOther === null) {
                showAlert('Por favor selecciona si se conocen o no', 'error');
                return;
            }

            const btn = document.getElementById('submitBtn');
            btn.disabled = true;
            btn.textContent = 'Enviando...';

            try {
                // Obtener el team_id
                const statusResponse = await fetch(`${API_BASE_URL}/sessions/tablet-connections/status/?connection_id=${connectionId}`);
                const statusData = await statusResponse.json();
                const teamId = statusData.team.id;

                // Crear o actualizar personalizaci√≥n (sin autenticaci√≥n para tablets)
                const response = await fetch(`${API_BASE_URL}/sessions/team-personalizations/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        team: teamId,
                        team_name: teamName,
                        team_members_know_each_other: knowEachOther
                    })
                });

                if (response.ok || response.status === 201) {
                    showAlert('¬°Personalizaci√≥n enviada exitosamente!', 'success');
                    btn.textContent = '‚úì Entregado';
                    
                    // Deshabilitar formulario
                    document.getElementById('teamNameInput').disabled = true;
                    document.getElementById('knowYesBtn').disabled = true;
                    document.getElementById('knowNoBtn').disabled = true;
                } else {
                    const data = await response.json();
                    showAlert(data.error || 'Error al enviar la personalizaci√≥n', 'error');
                    btn.disabled = false;
                    btn.textContent = 'Entregar Personalizaci√≥n';
                }
            } catch (error) {
                showAlert('Error de conexi√≥n: ' + error.message, 'error');
                btn.disabled = false;
                btn.textContent = 'Entregar Personalizaci√≥n';
            }
        }

        let anagramWords = [];
        let currentActivityId = null;
        let currentSessionStageId = null;

        async function loadAnagramActivity(activityId, stageId, gameSessionId) {
            try {
                currentActivityId = activityId;
                
                // Obtener datos de la actividad
                const activityResponse = await fetch(`${API_BASE_URL}/challenges/activities/${activityId}/`);
                if (!activityResponse.ok) {
                    showAlert('Error al cargar la actividad', 'error');
                    return;
                }
                
                const activityData = await activityResponse.json();
                const config = activityData.config_data || {};
                anagramWords = config.words || [];
                
                // Obtener session_stage (si no est√° ya definido)
                if (!currentSessionStageId) {
                    console.log('üîç Obteniendo session_stage en loadAnagramActivity...');
                    const stagesResponse = await fetch(`${API_BASE_URL}/sessions/session-stages/?game_session=${gameSessionId}`);
                    if (stagesResponse.ok) {
                        const stagesData = await stagesResponse.json();
                        const stages = stagesData.results || stagesData;
                        if (stages.length > 0) {
                            currentSessionStageId = stages[0].id;
                            console.log('‚úÖ currentSessionStageId obtenido en loadAnagramActivity:', currentSessionStageId);
                        } else {
                            console.warn('‚ö†Ô∏è No se encontraron session_stages en loadAnagramActivity');
                        }
                    } else {
                        console.error('‚ùå Error al obtener session_stages en loadAnagramActivity:', stagesResponse.status, stagesResponse.statusText);
                        const errorData = await stagesResponse.json().catch(() => ({}));
                        console.error('   Detalles del error:', errorData);
                    }
                } else {
                    console.log('‚úÖ currentSessionStageId ya est√° definido:', currentSessionStageId);
                }
                
                // Renderizar palabras
                renderAnagramWords(anagramWords);
                
                // Verificar si ya hay progreso guardado
                await checkExistingAnagramProgress(myTeamId, activityId);
                
            } catch (error) {
                console.error('Error loading anagram activity:', error);
                showAlert('Error al cargar la actividad: ' + error.message, 'error');
            }
        }

        let currentAnagramIndex = 0;
        let completedAnagrams = [];

        function renderAnagramWords(words) {
            // Actualizar total
            document.getElementById('totalWords').textContent = words.length;
            
            // Mostrar solo la palabra actual
            if (currentAnagramIndex >= words.length) {
                // Todas las palabras completadas
                const container = document.getElementById('anagramWordsContainer');
                container.innerHTML = `
                    <div style="text-align: center; padding: 40px; background: #d4edda; border-radius: 10px; border: 2px solid #28a745;">
                        <p style="font-size: 24px; color: #28a745; font-weight: bold;">‚úÖ ¬°Felicidades!</p>
                        <p style="color: #155724; margin-top: 10px;">Has completado todas las palabras</p>
                    </div>
                `;
                document.getElementById('anagramProgress').style.display = 'none';
                return;
            }
            
            const wordData = words[currentAnagramIndex];
            const anagram = wordData.anagram || '';
            const container = document.getElementById('anagramWordsContainer');
            
            container.innerHTML = `
                <div class="form-group" style="margin-bottom: 25px;">
                    <label style="display: block; margin-bottom: 10px; font-weight: 600; color: #333;">
                        Anagrama: <span style="font-size: 28px; letter-spacing: 4px; color: #667eea; font-weight: bold;">${anagram.toUpperCase()}</span>
                    </label>
                    <input 
                        type="text" 
                        id="anagramWordInput" 
                        data-word="${wordData.word}"
                        placeholder="Escribe la palabra correcta aqu√≠..."
                        style="width: 100%; padding: 20px; font-size: 20px; border: 3px solid #e0e0e0; border-radius: 10px; text-transform: lowercase; text-align: center;"
                        autocomplete="off"
                        required
                    >
                    <p style="margin-top: 10px; font-size: 14px; color: #666; text-align: center;">‚≠ê Cada palabra correcta = 5 tokens</p>
                    <button 
                        type="button" 
                        id="verifyAnagramBtn" 
                        onclick="verifyAnagram('${wordData.word}')"
                        style="width: 100%; margin-top: 15px; padding: 15px; font-size: 18px; background: #667eea; color: white; border: none; border-radius: 10px; cursor: pointer; font-weight: 600;"
                    >
                        ‚úì Verificar Respuesta
                    </button>
                    <div id="anagramFeedback" style="margin-top: 10px; text-align: center; font-weight: 600;"></div>
                </div>
            `;
            
            // Actualizar contador
            document.getElementById('currentWordNumber').textContent = currentAnagramIndex + 1;
        }

        async function verifyAnagram(correctWord) {
            const input = document.getElementById('anagramWordInput');
            const feedback = document.getElementById('anagramFeedback');
            const verifyBtn = document.getElementById('verifyAnagramBtn');
            
            if (!input || !input.value.trim()) {
                showAlert('Por favor escribe una respuesta', 'error');
                return;
            }
            
            const userAnswer = input.value.trim().toLowerCase();
            const isCorrect = userAnswer === correctWord.toLowerCase();
            
            if (isCorrect) {
                // Respuesta correcta
                input.disabled = true;
                input.style.borderColor = '#28a745';
                input.style.background = '#d4edda';
                feedback.innerHTML = '<span style="color: #28a745; font-size: 18px;">‚úÖ ¬°Correcto!</span>';
                verifyBtn.style.display = 'none';
                
                // Guardar respuesta
                completedAnagrams.push({
                    word: correctWord,
                    answer: userAnswer
                });
                
                // Enviar respuesta individual
                await submitSingleAnagram(correctWord, userAnswer);
                
                // Esperar un momento y mostrar siguiente palabra
                setTimeout(() => {
                    currentAnagramIndex++;
                    renderAnagramWords(anagramWords);
                }, 1500);
            } else {
                // Respuesta incorrecta
                input.style.borderColor = '#dc3545';
                input.style.background = '#f8d7da';
                feedback.innerHTML = '<span style="color: #dc3545; font-size: 18px;">‚ùå Incorrecto. Intenta de nuevo.</span>';
                
                // Limpiar feedback despu√©s de 2 segundos
                setTimeout(() => {
                    input.style.borderColor = '#e0e0e0';
                    input.style.background = 'white';
                    feedback.innerHTML = '';
                }, 2000);
            }
        }

        async function submitSingleAnagram(word, answer) {
            try {
                // Validar que todos los datos necesarios est√©n disponibles
                if (!myTeamId || !currentActivityId || !currentSessionStageId) {
                    console.error('‚ùå Error: Faltan datos necesarios:', {
                        myTeamId,
                        currentActivityId,
                        currentSessionStageId
                    });
                    showAlert('Error: Faltan datos necesarios. Por favor, recarga la p√°gina.', 'error');
                    return;
                }
                
                const requestData = {
                    team: myTeamId,
                    activity: currentActivityId,
                    session_stage: currentSessionStageId,
                    answers: [{ word: word, answer: answer }]
                };
                
                console.log('üì§ Enviando anagrama:', requestData);
                
                // Enviar solo esta palabra al backend
                const response = await fetch(`${API_BASE_URL}/sessions/team-activity-progress/submit_anagram/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });
                
                console.log('üì• Respuesta del servidor:', response.status, response.statusText);
                
                if (!response.ok) {
                    const errorData = await response.json().catch(() => ({ error: 'Error desconocido' }));
                    console.error('‚ùå Error en respuesta:', errorData);
                    showAlert(`Error al guardar: ${errorData.error || 'Error desconocido'}`, 'error');
                    return;
                }
                
                const data = await response.json();
                console.log('‚úÖ Respuesta exitosa:', data);
                const tokensEarned = data.tokens_earned || 0;
                
                if (tokensEarned > 0) {
                    showAlert(`¬°Correcto! +${tokensEarned} tokens`, 'success');
                }
                
                // Actualizar tokens desde el servidor (obtener total actualizado)
                await updateBasicState();
                
                // Guardar progreso en sessionStorage para evitar p√©rdida al recargar
                const progressKey = `anagram_progress_${myTeamId}_${currentActivityId}`;
                const existingProgress = JSON.parse(sessionStorage.getItem(progressKey) || '[]');
                const wordExists = existingProgress.some(p => p.word === word);
                if (!wordExists) {
                    existingProgress.push({ word, answer, correct: true });
                    sessionStorage.setItem(progressKey, JSON.stringify(existingProgress));
                }
            } catch (error) {
                console.error('‚ùå Error submitting anagram:', error);
                showAlert('Error de conexi√≥n: ' + error.message, 'error');
            }
        }

        async function checkExistingAnagramProgress(teamId, activityId) {
            try {
                if (!currentSessionStageId) return;
                
                const response = await fetch(`${API_BASE_URL}/sessions/team-activity-progress/?team=${teamId}&activity=${activityId}&session_stage=${currentSessionStageId}`);
                
                if (response.ok) {
                    const data = await response.json();
                    const results = data.results || data;
                    
                    if (results.length > 0) {
                        const progress = results[0];
                        const responseData = progress.response_data || {};
                        const answers = responseData.answers || [];
                        
                        // Restaurar progreso
                        completedAnagrams = answers;
                        currentAnagramIndex = answers.length;
                        
                        // Si est√° completado, mostrar pantalla de completado
                        if (progress.status === 'completed') {
                            currentAnagramIndex = anagramWords.length; // Mostrar pantalla de completado
                            renderAnagramWords(anagramWords);
                        } else {
                            // Continuar desde donde se qued√≥
                            renderAnagramWords(anagramWords);
                        }
                    }
                }
            } catch (error) {
                console.error('Error checking anagram progress:', error);
            }
        }

        // Variables para temporizadores
        let timerInterval = null;
        let timerIntervalPresentation = null;
        let timerIntervalPersonalization = null;
        let topicTimerInterval = null;
        let challengeTimerInterval = null;
        let bubbleMapTimerInterval = null;
        let prototypeTimerInterval = null;
        let pitchTimerInterval = null;
        let pitchPresentationTimerInterval = null;
        let timerStartTime = null;
        let timerDuration = null;
        
        // Variables para Etapa 2
        let bubbleMapNodes = [];
        let selectedTopicId = null;
        let selectedChallengeId = null;
        
        // Intentar restaurar timerStartTime desde sessionStorage
        const storedTimerStart = sessionStorage.getItem(`timerStartTime_${connectionId}`);
        if (storedTimerStart) {
            timerStartTime = parseInt(storedTimerStart);
        }

        async function startTimer(activityId, type, gameSessionId) {
            try {
                // Intentar restaurar desde sessionStorage primero
                const storedTimerStart = sessionStorage.getItem(`timerStartTime_${connectionId}_${activityId}`);
                const storedTimerDuration = sessionStorage.getItem(`timerDuration_${connectionId}_${activityId}`);
                
                if (storedTimerStart && storedTimerDuration) {
                    timerStartTime = parseInt(storedTimerStart);
                    timerDuration = parseInt(storedTimerDuration);
                    console.log('‚úÖ Temporizador restaurado desde sessionStorage:', {
                        startTime: new Date(timerStartTime).toISOString(),
                        duration: timerDuration
                    });
                } else {
                    // Obtener informaci√≥n del temporizador desde el endpoint centralizado
                    const timerResponse = await fetch(`${API_BASE_URL}/sessions/game-sessions/${gameSessionId}/activity_timer/`);
                    if (!timerResponse.ok) {
                        // Intentar leer el error como JSON o texto
                        let errorMessage = 'Error al obtener informaci√≥n del temporizador';
                        try {
                            const contentType = timerResponse.headers.get('content-type');
                            if (contentType && contentType.includes('application/json')) {
                                const errorData = await timerResponse.json();
                                errorMessage = errorData.error || errorMessage;
                            } else {
                                const errorText = await timerResponse.text();
                                console.error('Error del servidor (no JSON):', errorText);
                            }
                        } catch (e) {
                            console.error('Error al leer respuesta del servidor:', e);
                        }
                        throw new Error(errorMessage);
                    }
                    
                    // Verificar que la respuesta sea JSON antes de parsear
                    const contentType = timerResponse.headers.get('content-type');
                    if (!contentType || !contentType.includes('application/json')) {
                        const text = await timerResponse.text();
                        console.error('Respuesta no es JSON:', text);
                        throw new Error('El servidor devolvi√≥ una respuesta no v√°lida');
                    }
                    
                    const timerData = await timerResponse.json();
                    
                    if (timerData.error) {
                        throw new Error(timerData.error);
                    }
                    
                    timerDuration = timerData.timer_duration; // En segundos (desde el modelo, puede ser null)
                    
                    // Validar que timer_duration est√© configurado
                    if (timerDuration === null || timerDuration === undefined) {
                        console.warn('‚ö†Ô∏è La actividad no tiene timer_duration configurado. No se puede iniciar el temporizador.');
                        showAlert('La actividad no tiene tiempo configurado. Por favor, contacta al administrador.', 'error');
                        return;
                    }
                    
                    if (timerData.started_at) {
                        timerStartTime = new Date(timerData.started_at).getTime();
                    } else {
                        // Si no hay started_at, usar el tiempo actual del servidor
                        timerStartTime = new Date(timerData.current_time).getTime();
                    }
                    
                    // Guardar en sessionStorage para persistir entre recargas (solo si timerDuration es v√°lido)
                    if (timerDuration !== null && timerDuration !== undefined) {
                        sessionStorage.setItem(`timerStartTime_${connectionId}_${activityId}`, timerStartTime.toString());
                        sessionStorage.setItem(`timerDuration_${connectionId}_${activityId}`, timerDuration.toString());
                    }
                    
                    console.log('‚úÖ Temporizador inicializado desde servidor:', {
                        activityId: activityId,
                        duration: timerDuration,
                        startedAt: timerData.started_at
                    });
                }
                
                // Continuar con la l√≥gica del temporizador (solo si timerDuration es v√°lido)
                if (!timerDuration || timerDuration <= 0) {
                    console.warn('‚ö†Ô∏è No se puede iniciar el temporizador: timerDuration no es v√°lido');
                    return;
                }
                
                let timerDisplay = null;
                if (type === 'anagram') {
                    timerDisplay = document.getElementById('timerDisplay');
                } else if (type === 'presentation') {
                    timerDisplay = document.getElementById('timerDisplayPresentation');
                } else if (type === 'personalization') {
                    timerDisplay = document.getElementById('timerDisplayPersonalization');
                } else if (type === 'topic') {
                    timerDisplay = document.getElementById('timerDisplayTopic');
                } else if (type === 'challenge') {
                    timerDisplay = document.getElementById('timerDisplayChallenge');
                } else if (type === 'bubble_map') {
                    timerDisplay = document.getElementById('timerDisplayBubbleMap');
                } else if (type === 'prototype') {
                    timerDisplay = document.getElementById('timerDisplayPrototype');
                } else if (type === 'pitch') {
                    timerDisplay = document.getElementById('timerDisplayPitch');
                } else if (type === 'pitch_presentation') {
                    timerDisplay = document.getElementById('timerDisplayPitchPresentation');
                }
                
                if (timerDisplay) {
                    const updateTimer = () => {
                        // Obtener valores espec√≠ficos para este tipo de actividad
                        let currentStartTime = timerStartTime;
                        let currentDuration = timerDuration;
                        
                        // Si no hay datos en variables, intentar obtener desde sessionStorage
                        if (!currentStartTime || !currentDuration) {
                            const storedStart = sessionStorage.getItem(`timerStartTime_${connectionId}_${activityId}`);
                            const storedDuration = sessionStorage.getItem(`timerDuration_${connectionId}_${activityId}`);
                            if (!storedStart || !storedDuration) {
                                return; // No actualizar si faltan datos
                            }
                            currentStartTime = parseInt(storedStart);
                            currentDuration = parseInt(storedDuration);
                        }
                        
                        const elapsed = Math.floor((Date.now() - currentStartTime) / 1000);
                        const remaining = Math.max(0, currentDuration - elapsed);
                        
                        const minutes = Math.floor(remaining / 60);
                        const seconds = remaining % 60;
                        timerDisplay.textContent = `${String(minutes).padStart(2, '0')}:${String(seconds).padStart(2, '0')}`;
                        
                        if (remaining <= 0) {
                            if (type === 'anagram') {
                                clearInterval(timerInterval);
                                timerInterval = null;
                            } else if (type === 'presentation') {
                                clearInterval(timerIntervalPresentation);
                                timerIntervalPresentation = null;
                            } else if (type === 'personalization') {
                                clearInterval(timerIntervalPersonalization);
                                timerIntervalPersonalization = null;
                            } else if (type === 'topic') {
                                clearInterval(topicTimerInterval);
                                topicTimerInterval = null;
                            } else if (type === 'challenge') {
                                clearInterval(challengeTimerInterval);
                                challengeTimerInterval = null;
                            } else if (type === 'bubble_map') {
                                clearInterval(bubbleMapTimerInterval);
                                bubbleMapTimerInterval = null;
                            } else if (type === 'prototype') {
                                clearInterval(prototypeTimerInterval);
                                prototypeTimerInterval = null;
                            } else if (type === 'pitch') {
                                clearInterval(pitchTimerInterval);
                                pitchTimerInterval = null;
                            } else if (type === 'pitch_presentation') {
                                clearInterval(pitchPresentationTimerInterval);
                                pitchPresentationTimerInterval = null;
                            }
                            timerDisplay.textContent = '00:00';
                            showAlert('‚è±Ô∏è ¬°Tiempo agotado!', 'error');
                        }
                    };
                    
                    updateTimer();
                    if (type === 'anagram') {
                        timerInterval = setInterval(updateTimer, 1000);
                    } else if (type === 'presentation') {
                        timerIntervalPresentation = setInterval(updateTimer, 1000);
                    } else if (type === 'personalization') {
                        timerIntervalPersonalization = setInterval(updateTimer, 1000);
                    } else if (type === 'topic') {
                        topicTimerInterval = setInterval(updateTimer, 1000);
                    } else if (type === 'challenge') {
                        challengeTimerInterval = setInterval(updateTimer, 1000);
                    } else if (type === 'bubble_map') {
                        bubbleMapTimerInterval = setInterval(updateTimer, 1000);
                    } else if (type === 'prototype') {
                        prototypeTimerInterval = setInterval(updateTimer, 1000);
                    } else if (type === 'pitch') {
                        pitchTimerInterval = setInterval(updateTimer, 1000);
                    } else if (type === 'pitch_presentation') {
                        pitchPresentationTimerInterval = setInterval(updateTimer, 1000);
                    }
                }
            } catch (error) {
                console.error('Error starting timer:', error);
                showAlert('Error al iniciar temporizador: ' + error.message, 'error');
            }
        }

        async function handlePitchFormSubmit(event) {
            event.preventDefault();
            
            const introProblem = document.getElementById('pitchIntroProblem').value.trim();
            const solution = document.getElementById('pitchSolution').value.trim();
            const closing = document.getElementById('pitchClosing').value.trim();
            
            if (!introProblem || !solution || !closing) {
                showAlert('Por favor completa todos los campos del formulario', 'error');
                return;
            }
            
            if (!currentSessionStageId) {
                showAlert('Error: No se pudo obtener la etapa de sesi√≥n', 'error');
                return;
            }
            
            try {
                const submitBtn = document.getElementById('submitPitchBtn');
                submitBtn.disabled = true;
                submitBtn.textContent = 'Guardando...';
                
                const response = await fetch(`${API_BASE_URL}/sessions/team-activity-progress/save_pitch/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        team_id: myTeamId,
                        activity_id: currentActivityId,
                        session_stage_id: currentSessionStageId,
                        pitch_intro_problem: introProblem,
                        pitch_solution: solution,
                        pitch_closing: closing
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Error al guardar el pitch');
                }
                
                const data = await response.json();
                console.log('‚úÖ Pitch guardado exitosamente:', data);
                
                // Mostrar mensaje de √©xito
                document.getElementById('pitchSavedMessage').style.display = 'block';
                showAlert('‚úì Pitch guardado exitosamente', 'success');
                
                // Deshabilitar formulario
                document.getElementById('pitchIntroProblem').disabled = true;
                document.getElementById('pitchSolution').disabled = true;
                document.getElementById('pitchClosing').disabled = true;
                submitBtn.disabled = true;
                submitBtn.textContent = '‚úì Pitch Guardado';
                
                // Actualizar tokens si hubo cambios
                await updateBasicState();
                
            } catch (error) {
                console.error('Error al guardar pitch:', error);
                showAlert('Error al guardar el pitch: ' + error.message, 'error');
                const submitBtn = document.getElementById('submitPitchBtn');
                submitBtn.disabled = false;
                submitBtn.textContent = '‚úì Guardar Pitch';
            }
        }

        async function loadExistingPitch(gameSessionId) {
            try {
                if (!myTeamId || !currentActivityId || !currentSessionStageId) {
                    console.warn('‚ö†Ô∏è Faltan datos para cargar pitch existente');
                    return;
                }
                
                const response = await fetch(
                    `${API_BASE_URL}/sessions/team-activity-progress/?team=${myTeamId}&activity=${currentActivityId}&session_stage=${currentSessionStageId}`
                );
                
                if (!response.ok) {
                    console.warn('‚ö†Ô∏è No se pudo cargar pitch existente');
                    return;
                }
                
                const data = await response.json();
                const progressArray = Array.isArray(data) ? data : data.results || [];
                
                if (progressArray.length > 0) {
                    const progress = progressArray[0];
                    
                    if (progress.pitch_intro_problem) {
                        document.getElementById('pitchIntroProblem').value = progress.pitch_intro_problem;
                    }
                    if (progress.pitch_solution) {
                        document.getElementById('pitchSolution').value = progress.pitch_solution;
                    }
                    if (progress.pitch_closing) {
                        document.getElementById('pitchClosing').value = progress.pitch_closing;
                    }
                    
                    // Si est√° completado, deshabilitar formulario
                    if (progress.status === 'completed') {
                        document.getElementById('pitchIntroProblem').disabled = true;
                        document.getElementById('pitchSolution').disabled = true;
                        document.getElementById('pitchClosing').disabled = true;
                        document.getElementById('submitPitchBtn').disabled = true;
                        document.getElementById('submitPitchBtn').textContent = '‚úì Pitch Guardado';
                        document.getElementById('pitchSavedMessage').style.display = 'block';
                    }
                }
            } catch (error) {
                console.error('Error al cargar pitch existente:', error);
            }
        }

        async function loadPresentationStatus(gameSessionId) {
            try {
                if (!currentSessionStageId) {
                    console.warn('‚ö†Ô∏è No hay session_stage para cargar estado de presentaci√≥n');
                    // Intentar obtener session_stage para Etapa 4
                    try {
                        const stagesResponse = await fetch(`${API_BASE_URL}/sessions/session-stages/?game_session=${gameSessionId}`);
                        if (stagesResponse.ok) {
                            const stagesData = await stagesResponse.json();
                            const stages = stagesData.results || stagesData;
                            const stage4 = stages.find(s => s.stage_number === 4);
                            if (stage4) {
                                currentSessionStageId = stage4.id;
                                console.log('‚úÖ currentSessionStageId obtenido para presentaci√≥n de pitch:', currentSessionStageId);
                            }
                        }
                    } catch (e) {
                        console.error('Error obteniendo session_stage:', e);
                    }
                    if (!currentSessionStageId) {
                        return;
                    }
                }
                
                const response = await fetch(`${API_BASE_URL}/sessions/session-stages/${currentSessionStageId}/presentation_status/`);
                
                if (!response.ok) {
                    console.warn('‚ö†Ô∏è No se pudo cargar estado de presentaci√≥n');
                    return;
                }
                
                const data = await response.json();
                
                // Si no hay orden, mostrar mensaje de espera
                if (!data.presentation_order || data.presentation_order.length === 0) {
                    document.getElementById('waitingForOrder').style.display = 'block';
                    document.getElementById('presentationOrderContainer').style.display = 'none';
                    document.getElementById('yourTurnContainer').style.display = 'none';
                    document.getElementById('waitingTurnContainer').style.display = 'none';
                    document.getElementById('waitingForOrder').innerHTML = `
                        <div style="font-size: 48px; margin-bottom: 15px;">‚è≥</div>
                        <p style="color: #856404; font-weight: 600; font-size: 18px;">Esperando a que el profesor confirme el orden de presentaci√≥n...</p>
                    `;
                    return;
                }
                
                // Si hay orden pero no est√° confirmado (orden generado pero no iniciado), mostrar mensaje de preparaci√≥n
                if (!data.order_confirmed) {
                    document.getElementById('waitingForOrder').style.display = 'block';
                    document.getElementById('presentationOrderContainer').style.display = 'block';
                    document.getElementById('yourTurnContainer').style.display = 'none';
                    document.getElementById('waitingTurnContainer').style.display = 'none';
                    document.getElementById('waitingForOrder').innerHTML = `
                        <div style="font-size: 48px; margin-bottom: 15px;">üéØ</div>
                        <p style="color: #856404; font-weight: 600; font-size: 18px; margin-bottom: 10px;">¬°Prep√°rate para presentar!</p>
                        <p style="color: #856404; font-size: 16px;">El profesor ha configurado el orden de presentaci√≥n. Las presentaciones comenzar√°n pronto.</p>
                    `;
                    // Renderizar orden para que vean su posici√≥n
                    renderPresentationOrder(data.teams || [], data.presentation_order || []);
                    return;
                }
                
                document.getElementById('waitingForOrder').style.display = 'none';
                document.getElementById('presentationOrderContainer').style.display = 'block';
                
                // Renderizar orden de presentaci√≥n
                renderPresentationOrder(data.teams || [], data.presentation_order || []);
                
                // Obtener el estado de presentaci√≥n
                const presentationState = data.presentation_state || 'not_started';
                
                // Verificar si es su turno
                const isMyTurn = data.current_presentation_team_id === myTeamId;
                
                if (isMyTurn) {
                    // Manejar seg√∫n el estado de presentaci√≥n
                    if (presentationState === 'preparing') {
                        // Estado de preparaci√≥n - mostrar pantalla "Prep√°rense"
                        document.getElementById('presentationReadyContainer').style.display = 'block';
                        document.getElementById('yourTurnContainer').style.display = 'none';
                        document.getElementById('waitingTurnContainer').style.display = 'none';
                        
                        // Mostrar nombre del equipo
                        const myTeam = (data.teams || []).find(t => t.id === myTeamId);
                        if (myTeam) {
                            document.getElementById('presentationReadyTeamName').textContent = `Prep√°rense, ${myTeam.name}`;
                        }
                    } else if (presentationState === 'presenting') {
                        // Estado de presentaci√≥n activa - mostrar pantalla de presentaci√≥n con cron√≥metro
                        document.getElementById('presentationReadyContainer').style.display = 'none';
                        document.getElementById('yourTurnContainer').style.display = 'block';
                        document.getElementById('waitingTurnContainer').style.display = 'none';
                        
                        // Cargar su pitch
                        await loadMyPitchForPresentation(gameSessionId);
                        
                        // Iniciar temporizador (solo si no est√° corriendo)
                        const pitchPresentationTimerStart = sessionStorage.getItem(`timerStartTime_${connectionId}_${currentActivityId}`);
                        if (!pitchPresentationTimerInterval && !pitchPresentationTimerStart) {
                            await startTimer(currentActivityId, 'pitch_presentation', gameSessionId);
                        } else if (pitchPresentationTimerStart && !pitchPresentationTimerInterval) {
                            await startTimer(currentActivityId, 'pitch_presentation', gameSessionId);
                        }
                    } else {
                        // Otro estado - ocultar todo
                        document.getElementById('presentationReadyContainer').style.display = 'none';
                        document.getElementById('yourTurnContainer').style.display = 'none';
                        document.getElementById('waitingTurnContainer').style.display = 'block';
                    }
                } else {
                    // Esperando turno o escuchando otra presentaci√≥n
                    document.getElementById('yourTurnContainer').style.display = 'none';
                    document.getElementById('waitingTurnContainer').style.display = 'block';
                    
                    // Mostrar qu√© equipo est√° presentando
                    const currentTeam = (data.teams || []).find(t => t.id === data.current_presentation_team_id);
                    if (currentTeam) {
                        document.getElementById('currentPresenterName').textContent = `Turno del ${currentTeam.name}`;
                        
                        // Cargar prototipo del equipo que est√° presentando
                        await loadPresenterPrototype(gameSessionId, data.current_presentation_team_id);
                    }
                    
                    // Manejar evaluaci√≥n seg√∫n el estado de presentaci√≥n
                    // IMPORTANTE: Solo mostrar evaluaci√≥n cuando el estado es 'evaluating' y el equipo ya complet√≥ su presentaci√≥n
                    const completedTeamIds = data.completed_team_ids || [];
                    const presentationOrder = data.presentation_order || [];
                    const currentPresenterId = data.current_presentation_team_id;
                    
                    console.log('üìã Estado de presentaci√≥n:', presentationState);
                    console.log('üìã Equipos que ya completaron su presentaci√≥n:', completedTeamIds);
                    console.log('üìã Equipo actualmente presentando:', currentPresenterId);
                    
                    // Ocultar formulario por defecto
                    document.getElementById('evaluationFormContainer').style.display = 'none';
                    
                    // Solo mostrar evaluaci√≥n si:
                    // 1. El estado es 'evaluating' (el profesor finaliz√≥ la presentaci√≥n)
                    // 2. Hay un equipo que ya complet√≥ su presentaci√≥n
                    if (presentationState === 'evaluating' && completedTeamIds.length > 0) {
                        // Buscar el equipo que est√° siendo evaluado (el que acaba de presentar)
                        let evaluatedTeamId = null;
                        
                        // El equipo a evaluar es el que est√° en current_presentation_team_id
                        // porque el estado 'evaluating' significa que ese equipo acaba de terminar
                        if (currentPresenterId && completedTeamIds.includes(currentPresenterId) && currentPresenterId !== myTeamId) {
                            evaluatedTeamId = currentPresenterId;
                        } else {
                            // Fallback: buscar el √∫ltimo equipo que complet√≥
                            for (let i = presentationOrder.length - 1; i >= 0; i--) {
                                const teamId = presentationOrder[i];
                                if (completedTeamIds.includes(teamId) && teamId !== myTeamId) {
                                    evaluatedTeamId = teamId;
                                    break;
                                }
                            }
                        }
                        
                        // Solo mostrar formulario si encontramos un equipo que complet√≥
                        if (evaluatedTeamId) {
                            console.log('‚úÖ Mostrando formulario de evaluaci√≥n para el equipo que complet√≥:', evaluatedTeamId);
                            await checkIfCanEvaluate(gameSessionId, evaluatedTeamId, data.teams || []);
                        } else {
                            console.log('‚ùå No hay equipos completados disponibles para evaluar');
                            document.getElementById('evaluationFormContainer').style.display = 'none';
                        }
                    } else {
                        console.log('‚ùå No estamos en estado de evaluaci√≥n. Estado:', presentationState);
                        document.getElementById('evaluationFormContainer').style.display = 'none';
                    }
                }
                
            } catch (error) {
                console.error('Error loading presentation status:', error);
            }
        }

        function renderPresentationOrder(teams, order) {
            const orderList = document.getElementById('presentationOrderList');
            if (!orderList) return;
            
            orderList.innerHTML = '';
            
            order.forEach((teamId, index) => {
                const team = teams.find(t => t.id === teamId);
                if (!team) return;
                
                const isMyTeam = teamId === myTeamId;
                const orderItem = document.createElement('div');
                orderItem.style.cssText = `display: flex; align-items: center; gap: 15px; padding: 10px; background: ${isMyTeam ? '#fff3cd' : 'white'}; border-radius: 8px; border: ${isMyTeam ? '2px solid #ffc107' : 'none'};`;
                
                orderItem.innerHTML = `
                    <div style="background: ${isMyTeam ? '#ffc107' : '#667eea'}; color: ${isMyTeam ? '#000' : 'white'}; width: 35px; height: 35px; border-radius: 50%; display: flex; align-items: center; justify-content: center; font-weight: 700;">
                        ${index + 1}
                    </div>
                    <div style="flex: 1;">
                        <div style="font-weight: 600; color: #333;">${team.name}${isMyTeam ? ' (Tu equipo)' : ''}</div>
                        <div style="font-size: 14px; color: #666;">Equipo ${team.color}</div>
                    </div>
                    ${isMyTeam ? '<span style="background: #28a745; color: white; padding: 5px 12px; border-radius: 12px; font-size: 12px; font-weight: 600;">T√ö</span>' : ''}
                `;
                
                orderList.appendChild(orderItem);
            });
        }

        async function loadMyPitchForPresentation(gameSessionId) {
            try {
                if (!myTeamId || !currentSessionStageId) {
                    return;
                }
                
                // Obtener el pitch del formulario (actividad anterior - Etapa 4, actividad 1)
                const pitchFormActivityResponse = await fetch(`${API_BASE_URL}/challenges/activities/?stage=4&order_number=1`);
                const pitchFormData = await pitchFormActivityResponse.json();
                const pitchFormActivities = Array.isArray(pitchFormData) ? pitchFormData : pitchFormData.results || [];
                const pitchFormActivity = pitchFormActivities[0];
                
                if (!pitchFormActivity) return;
                
                const progressResponse = await fetch(
                    `${API_BASE_URL}/sessions/team-activity-progress/?team=${myTeamId}&activity=${pitchFormActivity.id}&session_stage=${currentSessionStageId}`
                );
                
                if (!progressResponse.ok) return;
                
                const progressData = await progressResponse.json();
                const progressArray = Array.isArray(progressData) ? progressData : progressData.results || [];
                
                if (progressArray.length > 0) {
                    const progress = progressArray[0];
                    const pitchDisplay = document.getElementById('pitchContentDisplay');
                    
                    pitchDisplay.innerHTML = `
                        <div style="margin-bottom: 15px;">
                            <strong style="color: #667eea;">üìã Introducci√≥n del Problema:</strong>
                            <p style="margin-top: 5px; color: #333; line-height: 1.6;">${progress.pitch_intro_problem || 'No disponible'}</p>
                        </div>
                        <div style="margin-bottom: 15px;">
                            <strong style="color: #667eea;">üí° Soluci√≥n:</strong>
                            <p style="margin-top: 5px; color: #333; line-height: 1.6;">${progress.pitch_solution || 'No disponible'}</p>
                        </div>
                        <div>
                            <strong style="color: #667eea;">üéØ Cierre:</strong>
                            <p style="margin-top: 5px; color: #333; line-height: 1.6;">${progress.pitch_closing || 'No disponible'}</p>
                        </div>
                    `;
                }
            } catch (error) {
                console.error('Error loading my pitch:', error);
            }
        }

        async function loadPresenterPrototype(gameSessionId, presenterTeamId) {
            try {
                // Obtener la actividad de prototipo (Etapa 3)
                const prototypeActivityResponse = await fetch(`${API_BASE_URL}/challenges/activities/?stage=3&order_number=1`);
                const prototypeActivityData = await prototypeActivityResponse.json();
                const prototypeActivities = Array.isArray(prototypeActivityData) ? prototypeActivityData : prototypeActivityData.results || [];
                const prototypeActivity = prototypeActivities[0];
                
                if (!prototypeActivity) return;
                
                // Obtener session_stage de Etapa 3
                const stagesResponse = await fetch(`${API_BASE_URL}/sessions/session-stages/?game_session=${gameSessionId}`);
                const stagesData = await stagesResponse.json();
                const stages = stagesData.results || stagesData;
                const stage3 = stages.find(s => s.stage_number === 3);
                
                if (!stage3) return;
                
                const progressResponse = await fetch(
                    `${API_BASE_URL}/sessions/team-activity-progress/?team=${presenterTeamId}&activity=${prototypeActivity.id}&session_stage=${stage3.id}`
                );
                
                if (!progressResponse.ok) return;
                
                const progressData = await progressResponse.json();
                const progressArray = Array.isArray(progressData) ? progressData : progressData.results || [];
                
                const prototypeContainer = document.getElementById('presenterPrototypeImage');
                
                if (progressArray.length > 0 && progressArray[0].prototype_image_url) {
                    prototypeContainer.innerHTML = `
                        <img src="${progressArray[0].prototype_image_url}" alt="Prototipo" style="max-width: 100%; max-height: 400px; border-radius: 10px; box-shadow: 0 4px 12px rgba(0,0,0,0.1);">
                    `;
                } else {
                    prototypeContainer.innerHTML = '<p style="color: #999;">Este equipo no ha subido un prototipo</p>';
                }
            } catch (error) {
                console.error('Error loading presenter prototype:', error);
            }
        }

        async function checkIfCanEvaluate(gameSessionId, evaluatedTeamId, teamsData = []) {
            try {
                if (!evaluatedTeamId || evaluatedTeamId === myTeamId) {
                    document.getElementById('evaluationFormContainer').style.display = 'none';
                    return;
                }
                
                console.log('üîç Verificando si puede evaluar al equipo:', evaluatedTeamId);
                
                // Verificar si ya evalu√≥ a este equipo
                const evaluationsResponse = await fetch(`${API_BASE_URL}/sessions/peer-evaluations/?evaluator_team=${myTeamId}&evaluated_team=${evaluatedTeamId}&game_session=${gameSessionId}`);
                if (!evaluationsResponse.ok) {
                    console.error('Error al verificar evaluaciones:', evaluationsResponse.status);
                    return;
                }
                
                const evaluationsData = await evaluationsResponse.json();
                const evaluations = Array.isArray(evaluationsData) ? evaluationsData : evaluationsData.results || [];
                
                // Verificar si el equipo ya complet√≥ su presentaci√≥n consultando el estado
                const statusResponse = await fetch(`${API_BASE_URL}/sessions/session-stages/${currentSessionStageId}/presentation_status/`);
                if (!statusResponse.ok) {
                    console.error('Error al obtener estado de presentaci√≥n:', statusResponse.status);
                    return;
                }
                
                const statusData = await statusResponse.json();
                const completedTeamIds = statusData.completed_team_ids || [];
                const presentationState = statusData.presentation_state || 'not_started';
                
                // Verificar si el equipo ya complet√≥ su presentaci√≥n (marc√≥ "Presentaci√≥n lista")
                const teamAlreadyCompleted = completedTeamIds.includes(evaluatedTeamId);
                
                console.log('üìä Estado de evaluaci√≥n:', {
                    presentationState,
                    evaluatedTeamId,
                    teamAlreadyCompleted,
                    hasExistingEvaluation: evaluations.length > 0,
                    completedTeamIds,
                    message: teamAlreadyCompleted ? 'El equipo YA complet√≥ su presentaci√≥n' : 'El equipo A√öN NO complet√≥ su presentaci√≥n'
                });
                
                // SOLO mostrar formulario si:
                // 1. El estado es 'evaluating' (el profesor finaliz√≥ la presentaci√≥n)
                // 2. El equipo YA complet√≥ su presentaci√≥n
                // 3. A√∫n no lo he evaluado
                if (presentationState === 'evaluating' && teamAlreadyCompleted && evaluatedTeamId && evaluatedTeamId !== myTeamId && evaluations.length === 0) {
                    // Obtener nombre del equipo desde los datos proporcionados o desde statusData
                    let evaluatedTeamName = `Equipo ${evaluatedTeamId}`;
                    
                    if (teamsData.length > 0) {
                        // Usar los datos de equipos que ya tenemos
                        const evaluatedTeam = teamsData.find(t => t.id === evaluatedTeamId);
                        if (evaluatedTeam) {
                            evaluatedTeamName = evaluatedTeam.name;
                        }
                    } else {
                        // Si no se proporcionaron datos, usar los de statusData
                        const teams = statusData.teams || [];
                        const evaluatedTeam = teams.find(t => t.id === evaluatedTeamId);
                        if (evaluatedTeam) {
                            evaluatedTeamName = evaluatedTeam.name;
                        }
                    }
                    
                    // Mostrar formulario de evaluaci√≥n
                    document.getElementById('evaluatedTeamName').textContent = `Eval√∫a la presentaci√≥n del ${evaluatedTeamName}`;
                    document.getElementById('evaluationFormContainer').style.display = 'block';
                    
                    // Guardar el ID del equipo evaluado en el formulario para usarlo al enviar
                    const evaluationForm = document.getElementById('evaluationForm');
                    if (evaluationForm) {
                        evaluationForm.dataset.evaluatedTeamId = evaluatedTeamId.toString();
                        console.log('‚úÖ Guardado evaluatedTeamId en formulario:', evaluatedTeamId);
                    } else {
                        console.error('‚ùå No se encontr√≥ el formulario de evaluaci√≥n');
                    }
                    
                    // Pre-llenar si ya existe evaluaci√≥n
                    if (evaluations.length > 0) {
                        const evaluation = evaluations[0];
                        document.getElementById('clarityScore').value = evaluation.criteria_scores?.clarity || 5;
                        document.getElementById('solutionScore').value = evaluation.criteria_scores?.solution || 5;
                        document.getElementById('presentationScore').value = evaluation.criteria_scores?.presentation || 5;
                        document.getElementById('evaluationFeedback').value = evaluation.feedback || '';
                        console.log('‚úÖ Pre-llenando evaluaci√≥n existente');
                    } else {
                        // Resetear valores por defecto si no hay evaluaci√≥n previa
                        document.getElementById('clarityScore').value = 5;
                        document.getElementById('solutionScore').value = 5;
                        document.getElementById('presentationScore').value = 5;
                        document.getElementById('evaluationFeedback').value = '';
                        console.log('‚úÖ Mostrando formulario de evaluaci√≥n vac√≠o');
                    }
                } else {
                    document.getElementById('evaluationFormContainer').style.display = 'none';
                    if (evaluations.length > 0) {
                        console.log('‚úÖ Ya evaluaste a este equipo anteriormente');
                    } else if (presentationState !== 'evaluating') {
                        console.log('‚ùå No estamos en estado de evaluaci√≥n. Estado:', presentationState);
                    } else if (!teamAlreadyCompleted) {
                        console.log('‚ùå El equipo a√∫n no ha completado su presentaci√≥n');
                    } else {
                        console.log('‚ùå No se puede evaluar a este equipo a√∫n');
                    }
                }
            } catch (error) {
                console.error('Error checking if can evaluate:', error);
                document.getElementById('evaluationFormContainer').style.display = 'none';
            }
        }

        async function markPresentationDone() {
            const btn = document.getElementById('markPresentationDoneBtn');
            if (!btn) {
                console.error('‚ùå No se encontr√≥ el bot√≥n markPresentationDoneBtn');
                return;
            }
            
            // Guardar estado original del bot√≥n
            const originalText = btn.textContent;
            const originalDisabled = btn.disabled;
            
            // Timeout de seguridad para evitar que se quede pegado en "Guardando..."
            const timeoutId = setTimeout(() => {
                console.warn('‚è±Ô∏è Timeout: La solicitud tard√≥ demasiado, restaurando bot√≥n...');
                btn.disabled = originalDisabled;
                btn.textContent = originalText;
                showAlert('La solicitud tard√≥ demasiado. Por favor, intenta de nuevo.', 'error');
            }, 10000); // 10 segundos de timeout
            
            try {
                btn.disabled = true;
                btn.textContent = 'Guardando...';
                
                console.log('üì§ Marcando presentaci√≥n como completada:', {
                    team_id: myTeamId,
                    activity_id: currentActivityId,
                    session_stage_id: currentSessionStageId
                });
                
                if (!currentSessionStageId) {
                    clearTimeout(timeoutId);
                    throw new Error('No se encontr√≥ session_stage_id');
                }
                
                if (!myTeamId) {
                    clearTimeout(timeoutId);
                    throw new Error('No se encontr√≥ team_id');
                }
                
                if (!currentActivityId) {
                    clearTimeout(timeoutId);
                    throw new Error('No se encontr√≥ activity_id');
                }
                
                const response = await fetch(`${API_BASE_URL}/sessions/session-stages/${currentSessionStageId}/mark_presentation_done/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        team_id: myTeamId,
                        activity_id: currentActivityId
                    })
                });
                
                clearTimeout(timeoutId); // Limpiar timeout si la respuesta lleg√≥
                
                console.log('üì• Respuesta recibida:', response.status, response.statusText);
                
                if (!response.ok) {
                    let errorData;
                    try {
                        errorData = await response.json();
                    } catch (e) {
                        errorData = { error: `Error HTTP ${response.status}: ${response.statusText}` };
                    }
                    console.error('‚ùå Error al marcar presentaci√≥n:', errorData);
                    throw new Error(errorData.error || errorData.detail || 'Error al marcar presentaci√≥n como completada');
                }
                
                const responseData = await response.json();
                console.log('‚úÖ Presentaci√≥n marcada como completada:', responseData);
                
                showAlert('‚úì Presentaci√≥n completada', 'success');
                
                // Actualizar el bot√≥n a completado
                btn.textContent = '‚úì Completado';
                btn.disabled = true;
                
                // Obtener gameSessionId
                try {
                    const connectionResponse = await fetch(`${API_BASE_URL}/sessions/tablet-connections/status/?connection_id=${connectionId}`);
                    if (connectionResponse.ok) {
                        const connectionData = await connectionResponse.json();
                        const gameSessionId = connectionData.game_session?.id;
                        
                        if (gameSessionId) {
                            // Recargar estado despu√©s de un peque√±o delay para que el usuario vea el mensaje
                            setTimeout(async () => {
                                try {
                                    await loadPresentationStatus(gameSessionId);
                                } catch (e) {
                                    console.error('Error al recargar estado de presentaci√≥n:', e);
                                }
                            }, 500);
                        }
                    }
                } catch (e) {
                    console.error('Error al obtener estado de conexi√≥n:', e);
                    // No es cr√≠tico, continuamos
                }
                
            } catch (error) {
                clearTimeout(timeoutId); // Asegurar que el timeout se limpie
                console.error('‚ùå Error marking presentation done:', error);
                showAlert('Error al completar presentaci√≥n: ' + error.message, 'error');
                
                // Restaurar estado original del bot√≥n
                btn.disabled = originalDisabled;
                btn.textContent = originalText;
            }
        }

        async function submitEvaluation(event) {
            event.preventDefault();
            
            try {
                const btn = document.getElementById('submitEvaluationBtn');
                btn.disabled = true;
                btn.textContent = 'Enviando...';
                
                const clarityScore = parseInt(document.getElementById('clarityScore').value);
                const solutionScore = parseInt(document.getElementById('solutionScore').value);
                const presentationScore = parseInt(document.getElementById('presentationScore').value);
                const feedback = document.getElementById('evaluationFeedback').value.trim();
                
                // Obtener el equipo evaluado desde el dataset del formulario (guardado cuando se mostr√≥ el formulario)
                const evaluationForm = document.getElementById('evaluationForm');
                let evaluatedTeamId = null;
                
                if (evaluationForm && evaluationForm.dataset.evaluatedTeamId) {
                    evaluatedTeamId = parseInt(evaluationForm.dataset.evaluatedTeamId);
                    console.log('‚úÖ Equipo evaluado obtenido del formulario:', evaluatedTeamId);
                } else {
                    console.error('‚ùå No se encontr√≥ evaluatedTeamId en el formulario. Datos del formulario:', {
                        exists: !!evaluationForm,
                        dataset: evaluationForm ? evaluationForm.dataset : 'N/A'
                    });
                    // Fallback: intentar obtenerlo del estado de presentaci√≥n
                    console.log('‚ö†Ô∏è No se encontr√≥ evaluatedTeamId en el formulario, intentando obtenerlo del estado...');
                    const statusResponse = await fetch(`${API_BASE_URL}/sessions/session-stages/${currentSessionStageId}/presentation_status/`);
                    const statusData = await statusResponse.json();
                    
                    // Buscar el √∫ltimo equipo que complet√≥ su presentaci√≥n
                    const completedTeamIds = statusData.completed_team_ids || [];
                    const presentationOrder = statusData.presentation_order || [];
                    
                    // Encontrar el equipo m√°s reciente que complet√≥ (y que no sea mi equipo)
                    for (let i = presentationOrder.length - 1; i >= 0; i--) {
                        const teamId = presentationOrder[i];
                        if (completedTeamIds.includes(teamId) && teamId !== myTeamId) {
                            evaluatedTeamId = teamId;
                            break;
                        }
                    }
                }
                
                if (!evaluatedTeamId) {
                    throw new Error('No se pudo identificar el equipo evaluado. Por favor, aseg√∫rate de que el equipo ya complet√≥ su presentaci√≥n.');
                }
                
                // Obtener game_session_id
                const connectionResponse = await fetch(`${API_BASE_URL}/sessions/tablet-connections/status/?connection_id=${connectionId}`);
                const connectionData = await connectionResponse.json();
                const gameSessionId = connectionData.game_session.id;
                
                const response = await fetch(`${API_BASE_URL}/sessions/peer-evaluations/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                    },
                    body: JSON.stringify({
                        evaluator_team_id: myTeamId,
                        evaluated_team_id: evaluatedTeamId,
                        game_session_id: gameSessionId,
                        criteria_scores: {
                            clarity: clarityScore,
                            solution: solutionScore,
                            presentation: presentationScore
                        },
                        feedback: feedback
                    })
                });
                
                if (!response.ok) {
                    const errorData = await response.json();
                    throw new Error(errorData.error || 'Error al enviar evaluaci√≥n');
                }
                
                showAlert('‚úì Evaluaci√≥n enviada exitosamente', 'success');
                
                // Restaurar bot√≥n
                btn.disabled = false;
                btn.textContent = '‚úì Enviar Evaluaci√≥n';
                
                // Ocultar formulario de evaluaci√≥n
                document.getElementById('evaluationFormContainer').style.display = 'none';
                
                // Limpiar el dataset para permitir evaluar al siguiente equipo
                if (evaluationForm) {
                    delete evaluationForm.dataset.evaluatedTeamId;
                }
                
                // Actualizar tokens y recargar estado de presentaci√≥n para mostrar siguiente evaluaci√≥n si existe
                await updateBasicState();
                
                // Recargar estado de presentaci√≥n para ver si hay otro equipo que evaluar
                // Reutilizamos gameSessionId que ya obtuvimos arriba
                await loadPresentationStatus(gameSessionId);
                
            } catch (error) {
                console.error('Error submitting evaluation:', error);
                showAlert('Error al enviar evaluaci√≥n: ' + error.message, 'error');
                btn.disabled = false;
                btn.textContent = '‚úì Enviar Evaluaci√≥n';
            }
        }

        async function checkExistingPresentationProgress(teamId, activityId) {
            try {
                if (!currentSessionStageId) return;
                
                const response = await fetch(`${API_BASE_URL}/sessions/team-activity-progress/?team=${teamId}&activity=${activityId}&session_stage=${currentSessionStageId}`);
                
                if (response.ok) {
                    const data = await response.json();
                    const results = data.results || data;
                    
                    if (results.length > 0 && results[0].status === 'completed') {
                        document.getElementById('presentationDoneBtn').textContent = '‚úì Completado';
                        document.getElementById('presentationDoneBtn').disabled = true;
                    }
                }
            } catch (error) {
                console.error('Error checking presentation progress:', error);
            }
        }

        async function handlePresentationDone() {
            const btn = document.getElementById('presentationDoneBtn');
            btn.disabled = true;
            btn.textContent = 'Enviando...';
            
            try {
                // Validar y obtener datos necesarios
                console.log('üîç Validando datos antes de enviar presentaci√≥n:', {
                    myTeamId,
                    currentActivityId,
                    currentSessionStageId,
                    connectionId
                });
                
                // Asegurar que currentSessionStageId est√© definido
                if (!currentSessionStageId) {
                    console.log('‚ö†Ô∏è currentSessionStageId no est√° definido, intentando obtenerlo...');
                    // Intentar obtener el session_stage desde el servidor
                    try {
                        const statusResponse = await fetch(`${API_BASE_URL}/sessions/tablet-connections/status/?connection_id=${connectionId}`);
                        if (statusResponse.ok) {
                            const statusData = await statusResponse.json();
                            const gameSessionId = statusData.game_session.id;
                            console.log('üì° Obteniendo session_stages para game_session:', gameSessionId);
                            const stagesResponse = await fetch(`${API_BASE_URL}/sessions/session-stages/?game_session=${gameSessionId}`);
                            if (stagesResponse.ok) {
                                const stagesData = await stagesResponse.json();
                                const stages = stagesData.results || stagesData;
                                if (stages.length > 0) {
                                    currentSessionStageId = stages[0].id;
                                    console.log('‚úÖ currentSessionStageId obtenido en handlePresentationDone:', currentSessionStageId);
                                } else {
                                    console.warn('‚ö†Ô∏è No se encontraron session_stages');
                                }
                            } else {
                                console.error('‚ùå Error al obtener session_stages:', stagesResponse.status, stagesResponse.statusText);
                                const errorData = await stagesResponse.json().catch(() => ({}));
                                console.error('   Detalles del error:', errorData);
                            }
                        } else {
                            console.error('‚ùå Error al obtener status de conexi√≥n:', statusResponse.status);
                        }
                    } catch (e) {
                        console.error('‚ùå Error obteniendo session_stage:', e);
                    }
                }
                
                // Validar que todos los datos est√©n disponibles
                if (!myTeamId) {
                    console.error('‚ùå myTeamId no est√° definido');
                    showAlert('Error: No se pudo identificar el equipo. Por favor, recarga la p√°gina.', 'error');
                    btn.disabled = false;
                    btn.textContent = '‚úì Listo - Hemos terminado de presentarnos';
                    return;
                }
                if (!currentActivityId) {
                    console.error('‚ùå currentActivityId no est√° definido');
                    showAlert('Error: No se pudo identificar la actividad. Por favor, recarga la p√°gina.', 'error');
                    btn.disabled = false;
                    btn.textContent = '‚úì Listo - Hemos terminado de presentarnos';
                    return;
                }
                if (!currentSessionStageId) {
                    console.error('‚ùå currentSessionStageId no est√° definido despu√©s de intentar obtenerlo');
                    showAlert('Error: No se pudo identificar la etapa de sesi√≥n. Por favor, recarga la p√°gina.', 'error');
                    btn.disabled = false;
                    btn.textContent = '‚úì Listo - Hemos terminado de presentarnos';
                    return;
                }
                
                console.log('‚úÖ Todos los datos est√°n disponibles, enviando presentaci√≥n...');
                
                // Crear progreso de actividad completada
                const requestData = {
                    team: myTeamId,
                    activity: currentActivityId,
                    session_stage: currentSessionStageId,
                    status: 'completed',
                    response_data: {
                        type: 'presentation',
                        completed: true
                    }
                };
                
                console.log('üì§ Enviando presentaci√≥n:', requestData);
                
                const response = await fetch(`${API_BASE_URL}/sessions/team-activity-progress/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify(requestData)
                });
                
                console.log('üì• Respuesta del servidor:', response.status, response.statusText);
                
                if (response.ok || response.status === 201) {
                    const data = await response.json();
                    console.log('‚úÖ Presentaci√≥n completada exitosamente:', data);
                    showAlert('¬°Presentaci√≥n completada!', 'success');
                    btn.textContent = '‚úì Completado';
                } else {
                    const errorData = await response.json().catch(() => ({ error: 'Error desconocido' }));
                    console.error('‚ùå Error al completar la presentaci√≥n:', errorData);
                    showAlert(errorData.error || errorData.detail || 'Error al completar la presentaci√≥n', 'error');
                    btn.disabled = false;
                    btn.textContent = '‚úì Listo - Hemos terminado de presentarnos';
                }
            } catch (error) {
                showAlert('Error de conexi√≥n: ' + error.message, 'error');
                btn.disabled = false;
                btn.textContent = '‚úì Listo - Hemos terminado de presentarnos';
            }
        }

        async function updateBasicState() {
            try {
                const statusResponse = await fetch(`${API_BASE_URL}/sessions/tablet-connections/status/?connection_id=${connectionId}`);
                if (statusResponse.ok) {
                    const statusData = await statusResponse.json();
                    const team = statusData.team;
                    document.getElementById('tokensCount').textContent = team.tokens_total || 0;
                }
            } catch (error) {
                console.error('Error updating basic state:', error);
            }
        }

        // Cargar estado inicial
        document.getElementById('loading').classList.add('show');
        loadGameState();

        // Control de polling: pausar cuando el usuario est√° interactuando
        let isUserInteracting = false;
        let lastInteractionTime = Date.now();
        
        // Detectar cuando el usuario est√° haciendo scroll o interactuando
        let scrollTimeout;
        window.addEventListener('scroll', () => {
            isUserInteracting = true;
            lastInteractionTime = Date.now();
            clearTimeout(scrollTimeout);
            scrollTimeout = setTimeout(() => {
                isUserInteracting = false;
            }, 1000); // Marcar como no interactuando despu√©s de 1 segundo sin scroll
        }, { passive: true });
        
        // Detectar cuando el usuario est√° escribiendo
        document.addEventListener('input', () => {
            isUserInteracting = true;
            lastInteractionTime = Date.now();
        });
        
        // Detectar cuando el usuario est√° haciendo clic o tocando
        document.addEventListener('mousedown', () => {
            isUserInteracting = true;
            lastInteractionTime = Date.now();
        });
        
        document.addEventListener('touchstart', () => {
            isUserInteracting = true;
            lastInteractionTime = Date.now();
        }, { passive: true });
        
        // Polling cada 5 segundos (aumentado de 3 a 5 para ser menos intrusivo)
        // Pausa autom√°ticamente si el usuario est√° interactuando
        const pollInterval = setInterval(async () => {
            // Pausar polling si el usuario est√° interactuando hace menos de 2 segundos
            if (isUserInteracting && (Date.now() - lastInteractionTime < 2000)) {
                return; // Saltar este ciclo de polling
            }
            
            // Si el usuario estaba interactuando pero ya pasaron 2 segundos, reanudar
            if (isUserInteracting && (Date.now() - lastInteractionTime >= 2000)) {
                isUserInteracting = false;
            }
            // Solo actualizar header y estado, NO recargar formularios
            const isAnagramActive = document.getElementById('anagramActivity').classList.contains('active');
            const isPresentationActive = document.getElementById('presentationActivity').classList.contains('active');
            const isTopicSelectionActive = document.getElementById('topicSelectionActivity')?.classList.contains('active') || false;
            const isChallengeViewActive = document.getElementById('challengeViewActivity')?.classList.contains('active') || false;
            const isBubbleMapActive = document.getElementById('bubbleMapActivity')?.classList.contains('active') || false;
            const isResultsActive = document.getElementById('resultsActivity').style.display === 'block';
            const isPrototypeActive = document.getElementById('prototypeUploadActivity')?.classList.contains('active') || false;
            const isPitchFormActive = document.getElementById('pitchFormActivity')?.classList.contains('active') || false;
            const isPitchPresentationActive = document.getElementById('pitchPresentationActivity')?.classList.contains('active') || false;
            
            // Si estamos en resultados, verificar si hay nueva etapa
            if (isResultsActive) {
                // Verificar si el profesor avanz√≥ a una nueva etapa
                try {
                    const statusResponse = await fetch(`${API_BASE_URL}/sessions/tablet-connections/status/?connection_id=${connectionId}`);
                    if (statusResponse.ok) {
                        const statusData = await statusResponse.json();
                        const gameSessionId = statusData.game_session.id;
                        const gameResponse = await fetch(`${API_BASE_URL}/sessions/game-sessions/${gameSessionId}/`);
                        if (gameResponse.ok) {
                            const gameData = await gameResponse.json();
                            
                            // Verificar si hay una actividad actual diferente a la que est√°bamos viendo
                            const hasCurrentActivity = gameData.current_activity && gameData.current_activity_name;
                            const currentStageNum = gameData.current_stage_number;
                            
                            // Guardar el estado anterior para comparar
                            if (!window.lastResultsCheck) {
                                window.lastResultsCheck = {
                                    activity_id: null,
                                    stage_number: null
                                };
                            }
                            
                            // Si hay una actividad actual y es diferente a la √∫ltima que vimos, recargar
                            if (hasCurrentActivity) {
                                const activityChanged = window.lastResultsCheck.activity_id !== gameData.current_activity;
                                const stageChanged = window.lastResultsCheck.stage_number !== currentStageNum;
                                
                                if (activityChanged || stageChanged) {
                                    console.log('‚úÖ Nueva actividad detectada despu√©s de resultados:', gameData.current_activity_name);
                                    console.log('   - Etapa:', currentStageNum);
                                    console.log('   - Actividad ID:', gameData.current_activity);
                                    console.log('   - Cambio detectado:', { activityChanged, stageChanged });
                                    window.lastResultsCheck = {
                                        activity_id: gameData.current_activity,
                                        stage_number: currentStageNum
                                    };
                                    loadGameState();
                                    return;
                                }
                            } else {
                                // Si no hay actividad pero el juego sigue corriendo, puede que estemos esperando
                                if (gameData.status === 'running') {
                                    // Solo loguear ocasionalmente para no saturar la consola
                                    if (!window.lastResultsCheck.lastLog || Date.now() - window.lastResultsCheck.lastLog > 10000) {
                                        console.log('‚è≥ En resultados, esperando nueva actividad...');
                                        window.lastResultsCheck.lastLog = Date.now();
                                    }
                                } else if (gameData.status === 'completed') {
                                    console.log('üéâ El juego ha sido completado');
                                    // Mostrar mensaje de juego completado
                                }
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error verificando nueva etapa:', error);
                }
                return;
            }
            
            // Si estamos en prototipo, verificar si la etapa se complet√≥
            if (isPrototypeActive) {
                try {
                    const statusResponse = await fetch(`${API_BASE_URL}/sessions/tablet-connections/status/?connection_id=${connectionId}`);
                    if (statusResponse.ok) {
                        const statusData = await statusResponse.json();
                        const gameSessionId = statusData.game_session.id;
                        const gameResponse = await fetch(`${API_BASE_URL}/sessions/game-sessions/${gameSessionId}/`);
                        if (gameResponse.ok) {
                            const gameData = await gameResponse.json();
                            console.log('üîç Verificando estado desde prototipo:', {
                                current_activity: gameData.current_activity,
                                current_activity_name: gameData.current_activity_name,
                                current_stage_number: gameData.current_stage_number
                            });
                            // Si no hay actividad actual, significa que la etapa est√° completada - mostrar resultados
                            if (!gameData.current_activity || !gameData.current_activity_name) {
                                console.log('üîÑ Etapa completada detectada desde prototipo, redirigiendo a resultados...');
                                loadGameState();
                                return;
                            }
                            // Si la actividad cambi√≥, tambi√©n recargar
                            if (gameData.current_activity !== currentActivityId) {
                                console.log('üîÑ Actividad cambi√≥ desde prototipo, recargando estado...');
                                loadGameState();
                                return;
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error verificando etapa completada desde prototipo:', error);
                }
                return;
            }
            
            // Si estamos en formulario de pitch, verificar si la etapa se complet√≥ o cambi√≥ la actividad
            if (isPitchFormActive) {
                try {
                    const statusResponse = await fetch(`${API_BASE_URL}/sessions/tablet-connections/status/?connection_id=${connectionId}`);
                    if (statusResponse.ok) {
                        const statusData = await statusResponse.json();
                        const gameSessionId = statusData.game_session.id;
                        const gameResponse = await fetch(`${API_BASE_URL}/sessions/game-sessions/${gameSessionId}/`);
                        if (gameResponse.ok) {
                            const gameData = await gameResponse.json();
                            console.log('üîç Verificando estado desde formulario de pitch:', {
                                current_activity: gameData.current_activity,
                                current_activity_name: gameData.current_activity_name,
                                current_stage_number: gameData.current_stage_number,
                                stored_activity_id: currentActivityId
                            });
                            
                            // Verificar si hay orden de presentaci√≥n configurado (incluso si current_activity a√∫n es formulario)
                            // Esto detecta cuando el profesor inici√≥ las presentaciones
                            try {
                                const stagesResponse = await fetch(`${API_BASE_URL}/sessions/session-stages/?game_session=${gameSessionId}`);
                                if (stagesResponse.ok) {
                                    const stagesData = await stagesResponse.json();
                                    const stages = stagesData.results || stagesData;
                                    const stage4 = stages.find(s => s.stage_number === 4);
                                    if (stage4) {
                                        const presentationStatusResponse = await fetch(`${API_BASE_URL}/sessions/session-stages/${stage4.id}/presentation_status/`);
                                        if (presentationStatusResponse.ok) {
                                            const presentationStatus = await presentationStatusResponse.json();
                                            // Si hay orden confirmado o hay un equipo presentando, significa que las presentaciones comenzaron
                                            if (presentationStatus.order_confirmed || presentationStatus.current_presentation_team_id) {
                                                console.log('üîÑ Presentaciones iniciadas detectadas, cambiando a actividad de presentaci√≥n...');
                                                // Actualizar currentActivityId si hay una nueva actividad
                                                if (gameData.current_activity && gameData.current_activity !== currentActivityId) {
                                                    currentActivityId = gameData.current_activity;
                                                }
                                                loadGameState();
                                                return;
                                            }
                                        }
                                    }
                                }
                            } catch (e) {
                                console.error('Error verificando estado de presentaci√≥n:', e);
                            }
                            
                            // Si no hay actividad actual, significa que la etapa est√° completada - mostrar resultados
                            if (!gameData.current_activity || !gameData.current_activity_name) {
                                console.log('üîÑ Etapa completada detectada desde formulario de pitch, redirigiendo a resultados...');
                                loadGameState();
                                return;
                            }
                            // Si la actividad cambi√≥ (por ejemplo, de "Formulario de Pitch" a "Presentaci√≥n del Pitch"), recargar
                            const newActivityId = gameData.current_activity;
                            const newActivityName = gameData.current_activity_name?.toLowerCase() || '';
                            
                            // Verificar si cambi√≥ el ID de la actividad
                            if (newActivityId !== currentActivityId) {
                                console.log('üîÑ Actividad cambi√≥ desde formulario de pitch (ID diferente):', {
                                    anterior: currentActivityId,
                                    nueva: newActivityId,
                                    nombre_nuevo: gameData.current_activity_name
                                });
                                // Actualizar currentActivityId antes de recargar
                                currentActivityId = newActivityId;
                                loadGameState();
                                return;
                            }
                            
                            // Tambi√©n verificar si el nombre de la actividad cambi√≥ (por si el ID es el mismo pero el nombre cambi√≥)
                            // Si estamos en formulario pero el nombre ahora incluye "presentacion" y no "formulario", es un cambio
                            if (newActivityName.includes('presentacion') && !newActivityName.includes('formulario')) {
                                console.log('üîÑ Detectado cambio a presentaci√≥n del pitch (nombre diferente), recargando estado...');
                                // Actualizar currentActivityId si est√° disponible
                                if (newActivityId) {
                                    currentActivityId = newActivityId;
                                }
                                loadGameState();
                                return;
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error verificando etapa completada desde formulario de pitch:', error);
                }
                // Actualizar estado b√°sico (tokens, etc.) sin recargar todo
                updateBasicState();
                return;
            }
            
            // Si estamos en presentaci√≥n de pitch, actualizar estado (solo si no est√° interactuando)
            if (isPitchPresentationActive) {
                // Solo actualizar si el usuario no est√° interactuando
                if (isUserInteracting && (Date.now() - lastInteractionTime < 2000)) {
                    return; // Saltar actualizaci√≥n si est√° interactuando
                }
                
                try {
                    const statusResponse = await fetch(`${API_BASE_URL}/sessions/tablet-connections/status/?connection_id=${connectionId}`);
                    if (statusResponse.ok) {
                        const statusData = await statusResponse.json();
                        const gameSessionId = statusData.game_session.id;
                        const gameResponse = await fetch(`${API_BASE_URL}/sessions/game-sessions/${gameSessionId}/`);
                        if (gameResponse.ok) {
                            const gameData = await gameResponse.json();
                            // Verificar si la actividad cambi√≥ (por ejemplo, si el profesor avanz√≥ a resultados)
                            if (!gameData.current_activity || !gameData.current_activity_name) {
                                console.log('üîÑ Etapa completada detectada desde presentaci√≥n de pitch, redirigiendo a resultados...');
                                loadGameState();
                                return;
                            }
                            // Si la actividad cambi√≥, recargar
                            if (gameData.current_activity !== currentActivityId) {
                                console.log('üîÑ Actividad cambi√≥ desde presentaci√≥n de pitch, recargando estado...');
                                loadGameState();
                                return;
                            }
                        }
                        // Cargar estado de presentaci√≥n (orden, turno actual, etc.) solo si no est√° interactuando
                        if (!isUserInteracting || (Date.now() - lastInteractionTime >= 2000)) {
                            await loadPresentationStatus(gameSessionId);
                        }
                    }
                } catch (error) {
                    console.error('Error updating presentation status:', error);
                }
                updateBasicState();
                return;
            }
            
            if (isAnagramActive || isPresentationActive || isTopicSelectionActive || isChallengeViewActive || isBubbleMapActive) {
                // Verificar primero si el estado del juego cambi√≥ (por ejemplo, si el profesor avanz√≥ de actividad)
                try {
                    const statusResponse = await fetch(`${API_BASE_URL}/sessions/tablet-connections/status/?connection_id=${connectionId}`);
                    if (statusResponse.ok) {
                        const statusData = await statusResponse.json();
                        const gameSessionId = statusData.game_session.id;
                        const gameResponse = await fetch(`${API_BASE_URL}/sessions/game-sessions/${gameSessionId}/`);
                        
                        if (gameResponse.ok) {
                            const gameData = await gameResponse.json();
                            // Si no hay actividad actual, significa que la etapa est√° completada - mostrar resultados
                            if (!gameData.current_activity_name || !gameData.current_activity) {
                                console.log('üîÑ Etapa completada detectada, redirigiendo a resultados...');
                                loadGameState();
                                return;
                            }
                            
                            // Verificar si la actividad cambi√≥ comparando con la actividad actual
                            const newActivityId = gameData.current_activity;
                            const newActivityName = gameData.current_activity_name?.toLowerCase() || '';
                            
                            if (newActivityId !== currentActivityId) {
                                console.log('üîÑ Cambio de actividad detectado:', {
                                    anterior: currentActivityId,
                                    nueva: newActivityId,
                                    nombre: newActivityName
                                });
                                // Recargar estado completo para mostrar la nueva actividad
                                loadGameState();
                                return;
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error verificando estado del juego:', error);
                }
                
                // Si no cambi√≥ el estado, solo actualizar tokens y estado b√°sico
                updateBasicState();
            } else {
                // Para otras actividades, cargar estado completo solo si no est√° interactuando
                if (!isUserInteracting) {
                    loadGameState();
                }
            }
        }, 5000); // Aumentado de 3 a 5 segundos para ser menos intrusivo

        // Limpiar intervalo cuando se cierra la p√°gina
        window.addEventListener('beforeunload', () => {
            if (pollInterval) {
                clearInterval(pollInterval);
            }
        });

        // ========== FUNCIONES PARA ETAPA 2: EMPAT√çA ==========

        let allTopicsCache = []; // Cache de todos los temas para re-renderizar sin recargar

        async function loadTopicsForSelection(gameSessionId) {
            try {
                // Obtener informaci√≥n de la sesi√≥n para obtener la facultad
                const sessionResponse = await fetch(`${API_BASE_URL}/sessions/game-sessions/${gameSessionId}/`);
                const sessionData = await sessionResponse.json();
                
                // Obtener course para obtener la facultad
                const courseResponse = await fetch(`${API_BASE_URL}/academic/courses/${sessionData.course}/`);
                if (!courseResponse.ok) {
                    throw new Error('Error al obtener informaci√≥n del curso');
                }
                const courseData = await courseResponse.json();
                
                // El serializer CourseSerializer incluye career (ID) y faculty_name (nombre)
                // Necesitamos el ID de la facultad, as√≠ que obtenemos la carrera primero
                if (!courseData.career) {
                    showAlert('Error: No se pudo obtener la informaci√≥n de la carrera', 'error');
                    return;
                }
                
                // Obtener la carrera para obtener el ID de la facultad
                const careerResponse = await fetch(`${API_BASE_URL}/academic/careers/${courseData.career}/`);
                if (!careerResponse.ok) {
                    showAlert('Error: No se pudo obtener la informaci√≥n de la carrera', 'error');
                    return;
                }
                const careerData = await careerResponse.json();
                
                if (!careerData.faculty) {
                    showAlert('Error: No se pudo obtener la informaci√≥n de la facultad', 'error');
                    return;
                }
                
                const facultyId = careerData.faculty;
                
                // Obtener temas filtrados por facultad
                const topicsResponse = await fetch(`${API_BASE_URL}/challenges/topics/?faculty=${facultyId}`);
                if (!topicsResponse.ok) {
                    throw new Error('Error al cargar temas');
                }

                const topicsData = await topicsResponse.json();
                const topics = topicsData.results || topicsData;
                allTopicsCache = topics; // Guardar en cache

                // Asegurar que currentSessionStageId sea el de Etapa 2 antes de buscar el progreso
                if (!currentSessionStageId) {
                    console.log('‚ö†Ô∏è currentSessionStageId no est√° definido en loadTopicsForSelection, obteni√©ndolo...');
                    const stagesResponse = await fetch(`${API_BASE_URL}/sessions/session-stages/?game_session=${gameSessionId}`);
                    if (stagesResponse.ok) {
                        const stagesData = await stagesResponse.json();
                        const stages = stagesData.results || stagesData;
                        const stage2 = stages.find(s => s.stage_number === 2);
                        if (stage2) {
                            currentSessionStageId = stage2.id;
                            console.log('‚úÖ currentSessionStageId obtenido en loadTopicsForSelection:', currentSessionStageId);
                        }
                    }
                } else {
                    // Verificar que el session_stage sea el de Etapa 2
                    const stagesResponse = await fetch(`${API_BASE_URL}/sessions/session-stages/?game_session=${gameSessionId}`);
                    if (stagesResponse.ok) {
                        const stagesData = await stagesResponse.json();
                        const stages = stagesData.results || stagesData;
                        const stage2 = stages.find(s => s.stage_number === 2);
                        if (stage2 && stage2.id !== currentSessionStageId) {
                            console.warn('‚ö†Ô∏è currentSessionStageId no corresponde a Etapa 2, corrigiendo...');
                            currentSessionStageId = stage2.id;
                            console.log('‚úÖ currentSessionStageId corregido:', currentSessionStageId);
                        }
                    }
                }

                // Verificar si ya hay un tema seleccionado
                const progressResponse = await fetch(
                    `${API_BASE_URL}/sessions/team-activity-progress/?team=${myTeamId}&activity=${currentActivityId}&session_stage=${currentSessionStageId}`
                );
                let selectedTopic = null;
                if (progressResponse.ok) {
                    const progressData = await progressResponse.json();
                    console.log('üìä Datos de progreso obtenidos:', progressData);
                    const progress = Array.isArray(progressData) ? progressData[0] : progressData.results?.[0];
                    console.log('üìä Progreso encontrado:', progress);
                    if (progress) {
                        console.log('üìä selected_topic en progreso:', progress.selected_topic);
                        if (progress.selected_topic) {
                            selectedTopic = progress.selected_topic;
                            // Manejar tanto objeto como ID
                            if (typeof selectedTopic === 'object') {
                                selectedTopicId = selectedTopic.id;
                            } else {
                                selectedTopicId = selectedTopic;
                                // Si es solo un ID, necesitamos obtener el objeto completo
                                const topicInCache = allTopicsCache.find(t => t.id === selectedTopicId);
                                if (topicInCache) {
                                    selectedTopic = topicInCache;
                                }
                            }
                            pendingTopicId = null; // Limpiar selecci√≥n pendiente si ya hay uno confirmado
                            console.log('‚úÖ Tema ya seleccionado:', selectedTopic);
                        } else {
                            console.log('‚ö†Ô∏è No hay tema seleccionado en el progreso');
                        }
                    }
                } else {
                    console.error('‚ùå Error al obtener progreso:', progressResponse.status);
                }

                renderTopics(topics, selectedTopic);
            } catch (error) {
                console.error('Error loading topics:', error);
                showAlert('Error al cargar temas: ' + error.message, 'error');
            }
        }

        let pendingTopicId = null; // Tema seleccionado pero no confirmado

        function renderTopics(topics, selectedTopic) {
            const container = document.getElementById('topicsContainer');
            
            if (topics.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No hay temas disponibles para tu facultad.</p>';
                return;
            }

            // Si hay un tema ya confirmado (selectedTopic), no mostrar selecci√≥n pendiente
            const topicToHighlight = selectedTopic ? selectedTopic.id : pendingTopicId;

            // Si hay un tema confirmado, no permitir seleccionar otros
            const hasConfirmedTopic = selectedTopic && (selectedTopic.id || (typeof selectedTopic === 'object' && selectedTopic.id));
            
            container.innerHTML = topics.map(topic => {
                const isSelected = selectedTopic && (selectedTopic.id === topic.id || (typeof selectedTopic === 'object' && selectedTopic.id === topic.id));
                const isPending = !hasConfirmedTopic && pendingTopicId === topic.id;
                const canSelect = !hasConfirmedTopic; // No permitir seleccionar si ya hay un tema confirmado
                
                return `
                    <div class="topic-card" 
                         style="background: ${isSelected ? '#d4edda' : isPending ? '#fff3cd' : 'white'}; border: 2px solid ${isSelected ? '#28a745' : isPending ? '#ffc107' : '#e0e0e0'}; border-radius: 10px; padding: 20px; cursor: ${canSelect ? 'pointer' : 'not-allowed'}; opacity: ${canSelect ? '1' : '0.6'}; transition: all 0.3s;" 
                         onclick="${canSelect && !isSelected ? `previewTopicSelection(${topic.id}, '${topic.name.replace(/'/g, "\\'")}')` : ''}">
                        <h3 style="color: #667eea; margin-bottom: 10px; font-size: 18px;">${topic.name}</h3>
                        ${topic.description ? `<p style="color: #666; font-size: 14px; line-height: 1.6;">${topic.description}</p>` : ''}
                        ${isSelected ? '<p style="color: #155724; font-weight: 600; margin-top: 10px;">‚úì Confirmado</p>' : isPending ? '<p style="color: #856404; font-weight: 600; margin-top: 10px;">‚è≥ Pendiente de confirmar</p>' : hasConfirmedTopic ? '<p style="color: #999; font-weight: 600; margin-top: 10px;">Tema ya seleccionado</p>' : ''}
                    </div>
                `;
            }).join('');

            if (selectedTopic) {
                document.getElementById('selectedTopicInfo').style.display = 'block';
                const topicName = typeof selectedTopic === 'object' ? selectedTopic.name : 'Tema seleccionado';
                document.getElementById('selectedTopicName').textContent = topicName;
                document.getElementById('confirmTopicBtn').style.display = 'none';
            } else if (pendingTopicId && !hasConfirmedTopic) {
                const pendingTopic = topics.find(t => t.id === pendingTopicId);
                if (pendingTopic) {
                    document.getElementById('selectedTopicInfo').style.display = 'block';
                    document.getElementById('selectedTopicName').textContent = pendingTopic.name;
                    document.getElementById('confirmTopicBtn').style.display = 'block';
                }
            } else {
                document.getElementById('selectedTopicInfo').style.display = 'none';
            }
        }

        function previewTopicSelection(topicId, topicName) {
            // Verificar si ya hay un tema confirmado
            if (selectedTopicId) {
                showAlert('Ya has confirmado un tema. No puedes cambiarlo.', 'error');
                return;
            }
            
            // Solo marcar como pendiente, no confirmar a√∫n
            pendingTopicId = topicId;
            
            // Re-renderizar usando el cache de temas
            if (allTopicsCache.length > 0) {
                renderTopics(allTopicsCache, null);
            }
        }

        async function confirmTopicSelection() {
            if (!pendingTopicId) {
                showAlert('Por favor selecciona un tema primero', 'error');
                return;
            }

            try {
                // Asegurar que tenemos todos los datos necesarios, especialmente session_stage
                if (!myTeamId || !currentActivityId) {
                    showAlert('Error: Faltan datos necesarios', 'error');
                    return;
                }

                // Obtener session_stage de la Etapa 2 si no est√° disponible o verificar que sea el correcto
                if (!currentSessionStageId) {
                    console.log('‚ö†Ô∏è currentSessionStageId no est√° definido, obteni√©ndolo...');
                    const statusResponse = await fetch(`${API_BASE_URL}/sessions/tablet-connections/status/?connection_id=${connectionId}`);
                    if (statusResponse.ok) {
                        const statusData = await statusResponse.json();
                        const stagesResponse = await fetch(`${API_BASE_URL}/sessions/session-stages/?game_session=${statusData.game_session.id}`);
                        if (stagesResponse.ok) {
                            const stagesData = await stagesResponse.json();
                            const stages = stagesData.results || stagesData;
                            const stage2 = stages.find(s => s.stage_number === 2);
                            if (stage2) {
                                currentSessionStageId = stage2.id;
                                console.log('‚úÖ currentSessionStageId obtenido:', currentSessionStageId);
                            } else {
                                throw new Error('No se encontr√≥ session_stage para Etapa 2');
                            }
                        } else {
                            throw new Error('Error al obtener session_stages');
                        }
                    } else {
                        throw new Error('Error al obtener estado de conexi√≥n');
                    }
                }

                console.log('üì§ Confirmando tema con:', {
                    team: myTeamId,
                    activity: currentActivityId,
                    session_stage: currentSessionStageId,
                    topic: pendingTopicId
                });

                const btn = document.getElementById('confirmTopicBtn');
                btn.disabled = true;
                btn.textContent = 'Confirmando...';

                const response = await fetch(`${API_BASE_URL}/sessions/team-activity-progress/select_topic/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        team: myTeamId,
                        activity: currentActivityId,
                        session_stage: currentSessionStageId,
                        topic: pendingTopicId
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Error al seleccionar tema');
                }

                const responseData = await response.json();
                console.log('‚úÖ Tema seleccionado, respuesta del servidor:', responseData);
                
                // Verificar que el tema se guard√≥ correctamente
                if (responseData.selected_topic) {
                    selectedTopicId = responseData.selected_topic.id;
                    showAlert('‚úì Tema seleccionado correctamente', 'success');
                    pendingTopicId = null; // Limpiar selecci√≥n pendiente
                    
                    // Recargar los temas para mostrar el estado confirmado
                    const statusResponse = await fetch(`${API_BASE_URL}/sessions/tablet-connections/status/?connection_id=${connectionId}`);
                    if (statusResponse.ok) {
                        const statusData = await statusResponse.json();
                        await loadTopicsForSelection(statusData.game_session.id);
                    }
                    await updateBasicState();
                } else {
                    console.error('‚ö†Ô∏è El tema no se guard√≥ correctamente en la respuesta');
                    showAlert('Error: El tema no se guard√≥ correctamente', 'error');
                    const btn = document.getElementById('confirmTopicBtn');
                    btn.disabled = false;
                    btn.textContent = '‚úì Confirmar Selecci√≥n';
                }
            } catch (error) {
                console.error('Error selecting topic:', error);
                showAlert('Error al seleccionar tema: ' + error.message, 'error');
                const btn = document.getElementById('confirmTopicBtn');
                btn.disabled = false;
                btn.textContent = '‚úì Confirmar Selecci√≥n';
            }
        }

        async function loadChallengeForView(gameSessionId) {
            try {
                // Asegurar que currentSessionStageId sea el de Etapa 2
                if (!currentSessionStageId) {
                    console.log('‚ö†Ô∏è currentSessionStageId no est√° definido en loadChallengeForView, obteni√©ndolo...');
                    const stagesResponse = await fetch(`${API_BASE_URL}/sessions/session-stages/?game_session=${gameSessionId}`);
                    if (stagesResponse.ok) {
                        const stagesData = await stagesResponse.json();
                        const stages = stagesData.results || stagesData;
                        const stage2 = stages.find(s => s.stage_number === 2);
                        if (stage2) {
                            currentSessionStageId = stage2.id;
                            console.log('‚úÖ currentSessionStageId obtenido en loadChallengeForView:', currentSessionStageId);
                        }
                    }
                }

                // Obtener la actividad de "Seleccionar Tema" para buscar el tema seleccionado
                const activityResponse = await fetch(`${API_BASE_URL}/challenges/activities/`);
                const activitiesData = await activityResponse.json();
                const activities = activitiesData.results || activitiesData;
                const topicSelectionActivity = activities.find(a => 
                    a.name.toLowerCase().includes('tema') || a.name.toLowerCase().includes('seleccionar')
                );
                
                if (!topicSelectionActivity) {
                    throw new Error('No se encontr√≥ la actividad de selecci√≥n de tema');
                }

                // Obtener el progreso de la actividad de selecci√≥n de tema
                const topicProgressResponse = await fetch(
                    `${API_BASE_URL}/sessions/team-activity-progress/?team=${myTeamId}&activity=${topicSelectionActivity.id}&session_stage=${currentSessionStageId}`
                );
                
                if (!topicProgressResponse.ok) {
                    throw new Error('Error al cargar progreso de selecci√≥n de tema');
                }

                const topicProgressData = await topicProgressResponse.json();
                const topicProgress = Array.isArray(topicProgressData) ? topicProgressData[0] : topicProgressData.results?.[0];
                
                if (!topicProgress || !topicProgress.selected_topic) {
                    document.getElementById('challengeContent').innerHTML = '<p style="color: #999; text-align: center; padding: 40px;">Primero debes seleccionar un tema en la actividad anterior.</p>';
                    return;
                }

                // Extraer el ID del tema (puede ser objeto o ID)
                let topicId;
                if (typeof topicProgress.selected_topic === 'object') {
                    topicId = topicProgress.selected_topic.id;
                } else {
                    topicId = topicProgress.selected_topic;
                }
                
                console.log('üìä Tema seleccionado ID:', topicId);
                
                // Cargar desaf√≠os del tema usando el ID
                const challengesResponse = await fetch(
                    `${API_BASE_URL}/challenges/challenges/?topic=${topicId}`
                );
                
                if (!challengesResponse.ok) {
                    throw new Error('Error al cargar desaf√≠os');
                }

                const challengesData = await challengesResponse.json();
                const challenges = challengesData.results || challengesData;
                
                console.log('üìä Desaf√≠os encontrados:', challenges);
                
                if (challenges.length === 0) {
                    document.getElementById('challengeContent').innerHTML = '<p style="color: #999; text-align: center; padding: 40px;">No hay desaf√≠os disponibles para este tema.</p>';
                    return;
                }

                // Verificar si ya hay un desaf√≠o seleccionado para esta actividad
                const currentProgressResponse = await fetch(
                    `${API_BASE_URL}/sessions/team-activity-progress/?team=${myTeamId}&activity=${currentActivityId}&session_stage=${currentSessionStageId}`
                );
                
                if (currentProgressResponse.ok) {
                    const currentProgressData = await currentProgressResponse.json();
                    const currentProgress = Array.isArray(currentProgressData) ? currentProgressData[0] : currentProgressData.results?.[0];
                    
                    if (currentProgress && currentProgress.selected_challenge) {
                        // Extraer el ID del desaf√≠o
                        if (typeof currentProgress.selected_challenge === 'object') {
                            selectedChallengeId = currentProgress.selected_challenge.id;
                        } else {
                            selectedChallengeId = currentProgress.selected_challenge;
                        }
                    }
                }

                // Verificar si ya hay un desaf√≠o seleccionado
                let selectedChallenge = null;
                if (selectedChallengeId) {
                    selectedChallenge = challenges.find(c => c.id === selectedChallengeId);
                    if (selectedChallenge) {
                        console.log('‚úÖ Desaf√≠o ya seleccionado:', selectedChallenge);
                    } else {
                        console.log('‚ö†Ô∏è No se encontr√≥ el desaf√≠o seleccionado en la lista');
                    }
                } else {
                    console.log('‚ö†Ô∏è No hay desaf√≠o seleccionado en el progreso');
                }

                renderChallenges(challenges, selectedChallenge);
            } catch (error) {
                console.error('Error loading challenge:', error);
                showAlert('Error al cargar desaf√≠o: ' + error.message, 'error');
                document.getElementById('challengesContainer').innerHTML = '<p style="color: #dc3545; text-align: center; padding: 40px;">Error al cargar el desaf√≠o. Por favor, recarga la p√°gina.</p>';
            }
        }

        let pendingChallengeId = null; // Desaf√≠o seleccionado pero no confirmado
        let allChallengesCache = []; // Cache de todos los desaf√≠os

        function renderChallenges(challenges, selectedChallenge) {
            const container = document.getElementById('challengesContainer');
            allChallengesCache = challenges;
            
            if (challenges.length === 0) {
                container.innerHTML = '<p style="text-align: center; color: #666; padding: 20px;">No hay desaf√≠os disponibles para este tema.</p>';
                return;
            }

            // Si hay un desaf√≠o ya confirmado (selectedChallenge), no mostrar selecci√≥n pendiente
            const challengeToHighlight = selectedChallenge ? selectedChallenge.id : pendingChallengeId;

            // Si hay un desaf√≠o confirmado, no permitir seleccionar otros
            const hasConfirmedChallenge = selectedChallenge && (selectedChallenge.id || (typeof selectedChallenge === 'object' && selectedChallenge.id));
            
            container.innerHTML = challenges.map(challenge => {
                const isSelected = selectedChallenge && (selectedChallenge.id === challenge.id || (typeof selectedChallenge === 'object' && selectedChallenge.id === challenge.id));
                const isPending = !hasConfirmedChallenge && pendingChallengeId === challenge.id;
                const canSelect = !hasConfirmedChallenge; // No permitir seleccionar si ya hay un desaf√≠o confirmado
                
                return `
                    <div class="challenge-card" 
                         style="background: ${isSelected ? '#d4edda' : isPending ? '#fff3cd' : 'white'}; border: 2px solid ${isSelected ? '#28a745' : isPending ? '#ffc107' : '#e0e0e0'}; border-radius: 10px; padding: 20px; cursor: ${canSelect ? 'pointer' : 'not-allowed'}; opacity: ${canSelect ? '1' : '0.6'}; transition: all 0.3s;" 
                         onclick="${canSelect && !isSelected ? `previewChallengeSelection(${challenge.id}, '${challenge.title.replace(/'/g, "\\'")}')` : ''}">
                        <h3 style="color: #667eea; margin-bottom: 10px; font-size: 18px;">${challenge.title}</h3>
                        ${challenge.user_story ? `<p style="color: #666; font-size: 14px; line-height: 1.6;">${challenge.user_story}</p>` : ''}
                        ${isSelected ? '<p style="color: #155724; font-weight: 600; margin-top: 10px;">‚úì Confirmado</p>' : isPending ? '<p style="color: #856404; font-weight: 600; margin-top: 10px;">‚è≥ Pendiente de confirmar</p>' : hasConfirmedChallenge ? '<p style="color: #999; font-weight: 600; margin-top: 10px;">Desaf√≠o ya seleccionado</p>' : ''}
                    </div>
                `;
            }).join('');

            if (selectedChallenge) {
                document.getElementById('selectedChallengeInfo').style.display = 'block';
                const challengeName = typeof selectedChallenge === 'object' ? selectedChallenge.title : 'Desaf√≠o seleccionado';
                document.getElementById('selectedChallengeName').textContent = challengeName;
                document.getElementById('confirmChallengeBtn').style.display = 'none';
            } else if (pendingChallengeId && !hasConfirmedChallenge) {
                const pendingChallenge = challenges.find(c => c.id === pendingChallengeId);
                if (pendingChallenge) {
                    document.getElementById('selectedChallengeInfo').style.display = 'block';
                    document.getElementById('selectedChallengeName').textContent = pendingChallenge.title;
                    document.getElementById('confirmChallengeBtn').style.display = 'block';
                }
            } else {
                document.getElementById('selectedChallengeInfo').style.display = 'none';
            }
        }

        function previewChallengeSelection(challengeId, challengeTitle) {
            // Verificar si ya hay un desaf√≠o confirmado
            if (selectedChallengeId) {
                showAlert('Ya has confirmado un desaf√≠o. No puedes cambiarlo.', 'error');
                return;
            }
            
            // Solo marcar como pendiente, no confirmar a√∫n
            pendingChallengeId = challengeId;
            
            // Re-renderizar usando el cache de desaf√≠os
            if (allChallengesCache.length > 0) {
                renderChallenges(allChallengesCache, null);
            }
        }

        async function confirmChallengeSelection() {
            if (!pendingChallengeId) {
                showAlert('Por favor selecciona un desaf√≠o primero', 'error');
                return;
            }

            try {
                // Asegurar que tenemos todos los datos necesarios, especialmente session_stage
                if (!myTeamId || !currentActivityId) {
                    showAlert('Error: Faltan datos necesarios', 'error');
                    return;
                }

                // Obtener session_stage de la Etapa 2 si no est√° disponible o verificar que sea el correcto
                if (!currentSessionStageId) {
                    console.log('‚ö†Ô∏è currentSessionStageId no est√° definido, obteni√©ndolo...');
                    const statusResponse = await fetch(`${API_BASE_URL}/sessions/tablet-connections/status/?connection_id=${connectionId}`);
                    if (statusResponse.ok) {
                        const statusData = await statusResponse.json();
                        const stagesResponse = await fetch(`${API_BASE_URL}/sessions/session-stages/?game_session=${statusData.game_session.id}`);
                        if (stagesResponse.ok) {
                            const stagesData = await stagesResponse.json();
                            const stages = stagesData.results || stagesData;
                            const stage2 = stages.find(s => s.stage_number === 2);
                            if (stage2) {
                                currentSessionStageId = stage2.id;
                                console.log('‚úÖ currentSessionStageId obtenido:', currentSessionStageId);
                            } else {
                                throw new Error('No se encontr√≥ session_stage para Etapa 2');
                            }
                        } else {
                            throw new Error('Error al obtener session_stages');
                        }
                    } else {
                        throw new Error('Error al obtener estado de conexi√≥n');
                    }
                }

                console.log('üì§ Confirmando desaf√≠o con:', {
                    team: myTeamId,
                    activity: currentActivityId,
                    session_stage: currentSessionStageId,
                    challenge: pendingChallengeId
                });

                const btn = document.getElementById('confirmChallengeBtn');
                btn.disabled = true;
                btn.textContent = 'Confirmando...';

                const response = await fetch(`${API_BASE_URL}/sessions/team-activity-progress/select_challenge/`, {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({
                        team: myTeamId,
                        activity: currentActivityId,
                        session_stage: currentSessionStageId,
                        challenge: pendingChallengeId
                    })
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Error al seleccionar desaf√≠o');
                }

                const responseData = await response.json();
                console.log('‚úÖ Desaf√≠o seleccionado, respuesta del servidor:', responseData);
                
                // Verificar que el desaf√≠o se guard√≥ correctamente
                if (responseData.selected_challenge) {
                    selectedChallengeId = responseData.selected_challenge.id;
                    showAlert('‚úì Desaf√≠o seleccionado correctamente', 'success');
                    pendingChallengeId = null; // Limpiar selecci√≥n pendiente
                    
                    // Recargar los desaf√≠os para mostrar el estado confirmado
                    const statusResponse = await fetch(`${API_BASE_URL}/sessions/tablet-connections/status/?connection_id=${connectionId}`);
                    if (statusResponse.ok) {
                        const statusData = await statusResponse.json();
                        await loadChallengeForView(statusData.game_session.id);
                    }
                    await updateBasicState();
                } else {
                    console.error('‚ö†Ô∏è El desaf√≠o no se guard√≥ correctamente en la respuesta');
                    showAlert('Error: El desaf√≠o no se guard√≥ correctamente', 'error');
                    const btn = document.getElementById('confirmChallengeBtn');
                    btn.disabled = false;
                    btn.textContent = '‚úì Confirmar Selecci√≥n';
                }
            } catch (error) {
                console.error('Error selecting challenge:', error);
                showAlert('Error al seleccionar desaf√≠o: ' + error.message, 'error');
                const btn = document.getElementById('confirmChallengeBtn');
                btn.disabled = false;
                btn.textContent = '‚úì Confirmar Selecci√≥n';
            }
        }



        async function loadBubbleMapForEdit(gameSessionId) {
            try {
                // Obtener bubble map existente
                const mapResponse = await fetch(
                    `${API_BASE_URL}/sessions/team-bubble-maps/?team=${myTeamId}&session_stage=${currentSessionStageId}`
                );
                
                if (mapResponse.ok) {
                    const mapData = await mapResponse.json();
                    const bubbleMap = Array.isArray(mapData) ? mapData[0] : mapData.results?.[0];
                    
                    if (bubbleMap && bubbleMap.map_data && bubbleMap.map_data.nodes) {
                        bubbleMapNodes = bubbleMap.map_data.nodes || [];
                        renderBubbleMap();
                    }
                }
            } catch (error) {
                console.error('Error loading bubble map:', error);
            }
        }

        function addBubbleNode() {
            const text = prompt('Ingresa el texto de la burbuja:');
            if (!text || !text.trim()) {
                return;
            }

            const node = {
                id: Date.now(),
                text: text.trim(),
                x: Math.random() * 300 + 50,
                y: Math.random() * 200 + 50
            };

            bubbleMapNodes.push(node);
            renderBubbleMap();
        }

        function renderBubbleMap() {
            const canvas = document.getElementById('bubbleMapCanvas');
            const empty = document.getElementById('bubbleMapEmpty');
            
            if (bubbleMapNodes.length === 0) {
                if (empty) empty.style.display = 'block';
                canvas.innerHTML = '<div id="bubbleMapEmpty" style="text-align: center; color: #999; padding: 40px; font-style: italic;">No hay burbujas a√∫n. Haz clic en "Agregar Burbuja" para comenzar.</div>';
                return;
            }

            if (empty) empty.style.display = 'none';
            
            canvas.innerHTML = bubbleMapNodes.map((node, index) => {
                const isCentral = index === 0;
                return `
                    <div class="bubble-node" 
                         style="position: absolute; left: ${node.x}px; top: ${node.y}px; background: ${isCentral ? '#764ba2' : '#667eea'}; color: white; padding: 12px 18px; border-radius: 25px; font-size: ${isCentral ? '16px' : '14px'}; font-weight: ${isCentral ? '700' : '500'}; cursor: move; max-width: 200px; word-wrap: break-word; box-shadow: 0 3px 10px rgba(0,0,0,0.2);"
                         draggable="true"
                         ondragstart="dragBubble(event, ${node.id})"
                         ondrop="dropBubble(event, ${node.id})"
                         ondragover="event.preventDefault()">
                        ${node.text}
                        <button onclick="deleteBubbleNode(${node.id})" style="background: rgba(255,255,255,0.3); border: none; color: white; border-radius: 50%; width: 24px; height: 24px; cursor: pointer; margin-left: 8px; font-size: 12px;">√ó</button>
                    </div>
                `;
            }).join('') + '<div id="bubbleMapEmpty" style="display: none;"></div>';
        }

        function dragBubble(event, nodeId) {
            event.dataTransfer.setData('nodeId', nodeId);
        }

        function dropBubble(event, nodeId) {
            event.preventDefault();
            const draggedNodeId = parseInt(event.dataTransfer.getData('nodeId'));
            const node = bubbleMapNodes.find(n => n.id === draggedNodeId);
            if (node) {
                const rect = event.currentTarget.parentElement.getBoundingClientRect();
                node.x = event.clientX - rect.left;
                node.y = event.clientY - rect.top;
                renderBubbleMap();
            }
        }

        function deleteBubbleNode(nodeId) {
            if (confirm('¬øEliminar esta burbuja?')) {
                bubbleMapNodes = bubbleMapNodes.filter(n => n.id !== nodeId);
                renderBubbleMap();
            }
        }

        async function saveBubbleMap() {
            try {
                if (!myTeamId || !currentSessionStageId) {
                    showAlert('Error: Faltan datos necesarios', 'error');
                    return;
                }

                if (bubbleMapNodes.length === 0) {
                    showAlert('Agrega al menos una burbuja antes de guardar', 'error');
                    return;
                }

                const mapData = {
                    nodes: bubbleMapNodes,
                    edges: [] // Por ahora sin conexiones
                };

                // Verificar si ya existe un bubble map
                const existingResponse = await fetch(
                    `${API_BASE_URL}/sessions/team-bubble-maps/?team=${myTeamId}&session_stage=${currentSessionStageId}`
                );
                
                let response;
                if (existingResponse.ok) {
                    const existingData = await existingResponse.json();
                    const existing = Array.isArray(existingData) ? existingData[0] : existingData.results?.[0];
                    
                    if (existing) {
                        // Actualizar existente
                        response = await fetch(`${API_BASE_URL}/sessions/team-bubble-maps/${existing.id}/`, {
                            method: 'PATCH',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                map_data: mapData
                            })
                        });
                    } else {
                        // Crear nuevo
                        response = await fetch(`${API_BASE_URL}/sessions/team-bubble-maps/`, {
                            method: 'POST',
                            headers: {
                                'Content-Type': 'application/json'
                            },
                            body: JSON.stringify({
                                team: myTeamId,
                                session_stage: currentSessionStageId,
                                map_data: mapData
                            })
                        });
                    }
                } else {
                    // Crear nuevo
                    response = await fetch(`${API_BASE_URL}/sessions/team-bubble-maps/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            team: myTeamId,
                            session_stage: currentSessionStageId,
                            map_data: mapData
                        })
                    });
                }

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Error al guardar bubble map');
                }

                // Marcar la actividad como completada
                if (currentActivityId) {
                    await fetch(`${API_BASE_URL}/sessions/team-activity-progress/`, {
                        method: 'POST',
                        headers: {
                            'Content-Type': 'application/json'
                        },
                        body: JSON.stringify({
                            team: myTeamId,
                            activity: currentActivityId,
                            session_stage: currentSessionStageId,
                            status: 'completed',
                            progress_percentage: 100
                        })
                    });
                }

                showAlert('‚úì Bubble map guardado correctamente', 'success');
                await updateBasicState();
            } catch (error) {
                console.error('Error saving bubble map:', error);
                showAlert('Error al guardar: ' + error.message, 'error');
            }
        }

        // ========== FUNCIONES PARA ETAPA 3: CREATIVIDAD ==========

        let selectedPrototypeImage = null;

        function handleImageSelect(event) {
            const file = event.target.files[0];
            if (!file) return;

            if (!file.type.startsWith('image/')) {
                showAlert('Por favor selecciona un archivo de imagen', 'error');
                return;
            }

            if (file.size > 5 * 1024 * 1024) {
                showAlert('La imagen es demasiado grande. M√°ximo 5MB', 'error');
                return;
            }

            selectedPrototypeImage = file;

            const reader = new FileReader();
            reader.onload = (e) => {
                document.getElementById('prototypePreviewImage').src = e.target.result;
                document.getElementById('prototypePreview').style.display = 'block';
            };
            reader.readAsDataURL(file);
        }

        function cancelImageSelection() {
            selectedPrototypeImage = null;
            document.getElementById('prototypeImageInput').value = '';
            document.getElementById('prototypePreview').style.display = 'none';
        }

        async function uploadPrototype() {
            if (!selectedPrototypeImage) {
                showAlert('Por favor selecciona una imagen primero', 'error');
                return;
            }

            // Asegurar que tenemos todos los datos necesarios, especialmente currentSessionStageId
            if (!myTeamId || !currentActivityId) {
                showAlert('Error: Faltan datos necesarios', 'error');
                return;
            }
            
            // Si no tenemos currentSessionStageId, obtenerlo ahora
            if (!currentSessionStageId) {
                console.log('‚ö†Ô∏è currentSessionStageId no est√° definido, obteni√©ndolo...');
                try {
                    const statusResponse = await fetch(`${API_BASE_URL}/sessions/tablet-connections/status/?connection_id=${connectionId}`);
                    if (statusResponse.ok) {
                        const statusData = await statusResponse.json();
                        const gameSessionId = statusData.game_session.id;
                        const stagesResponse = await fetch(`${API_BASE_URL}/sessions/session-stages/?game_session=${gameSessionId}`);
                        if (stagesResponse.ok) {
                            const stagesData = await stagesResponse.json();
                            const stages = stagesData.results || stagesData;
                            const stage3 = stages.find(s => s.stage_number === 3);
                            if (stage3) {
                                currentSessionStageId = stage3.id;
                                console.log('‚úÖ currentSessionStageId obtenido antes de subir:', currentSessionStageId);
                            } else {
                                showAlert('Error: No se pudo encontrar la etapa de sesi√≥n', 'error');
                                return;
                            }
                        }
                    }
                } catch (error) {
                    console.error('Error obteniendo session_stage:', error);
                    showAlert('Error: No se pudo obtener la etapa de sesi√≥n', 'error');
                    return;
                }
            }
            
            if (!currentSessionStageId) {
                showAlert('Error: No se pudo identificar la etapa de sesi√≥n', 'error');
                return;
            }
            
            console.log('üì§ Subiendo prototipo con:', {
                team: myTeamId,
                activity: currentActivityId,
                session_stage: currentSessionStageId
            });

            try {
                const formData = new FormData();
                formData.append('team', myTeamId);
                formData.append('activity', currentActivityId);
                formData.append('session_stage', currentSessionStageId);
                formData.append('image', selectedPrototypeImage);

                const btn = document.querySelector('#prototypeUploadContainer .submit-btn');
                btn.disabled = true;
                btn.textContent = 'Subiendo...';

                const response = await fetch(`${API_BASE_URL}/sessions/team-activity-progress/upload_prototype/`, {
                    method: 'POST',
                    body: formData
                });

                if (!response.ok) {
                    const error = await response.json();
                    throw new Error(error.error || 'Error al subir prototipo');
                }

                const responseData = await response.json();
                console.log('‚úÖ Prototipo subido exitosamente:', responseData);

                if (responseData.prototype_image_url) {
                    console.log('‚úÖ Mostrando imagen subida:', responseData.prototype_image_url);
                    
                    // Ocultar preview
                    const preview = document.getElementById('prototypePreview');
                    if (preview) {
                        preview.style.display = 'none';
                    }
                    
                    // Ocultar el contenedor de subida (botones e input)
                    const uploadContainer = document.getElementById('prototypeUploadContainer');
                    if (uploadContainer) {
                        uploadContainer.style.display = 'none';
                        console.log('‚úÖ Contenedor de subida ocultado');
                    }
                    
                    // Mostrar imagen subida (ahora est√° fuera del contenedor de subida)
                    const uploadedImage = document.getElementById('prototypeUploadedImage');
                    const uploadedContainer = document.getElementById('prototypeUploaded');
                    if (uploadedImage && uploadedContainer) {
                        uploadedImage.src = responseData.prototype_image_url;
                        uploadedContainer.style.display = 'block';
                        console.log('‚úÖ Contenedor de imagen subida mostrado');
                        console.log('   - URL de imagen:', responseData.prototype_image_url);
                    } else {
                        console.error('‚ùå No se encontraron elementos para mostrar imagen subida');
                        console.error('   - uploadedImage:', uploadedImage);
                        console.error('   - uploadedContainer:', uploadedContainer);
                    }
                    
                    // Limpiar selecci√≥n
                    selectedPrototypeImage = null;
                    const imageInput = document.getElementById('prototypeImageInput');
                    if (imageInput) {
                        imageInput.value = '';
                    }
                } else {
                    console.warn('‚ö†Ô∏è No se recibi√≥ prototype_image_url en la respuesta');
                    console.warn('   - responseData:', responseData);
                }

                showAlert('‚úì Prototipo subido exitosamente', 'success');
                
                // Recargar el estado del prototipo para asegurar sincronizaci√≥n
                // Obtener gameSessionId desde el status
                try {
                    const statusResponse = await fetch(`${API_BASE_URL}/sessions/tablet-connections/status/?connection_id=${connectionId}`);
                    if (statusResponse.ok) {
                        const statusData = await statusResponse.json();
                        const gameSessionId = statusData.game_session.id;
                        await loadPrototypeStatus(gameSessionId);
                    }
                } catch (error) {
                    console.error('Error obteniendo gameSessionId:', error);
                }
                await updateBasicState();
            } catch (error) {
                console.error('Error uploading prototype:', error);
                showAlert('Error al subir prototipo: ' + error.message, 'error');
                const btn = document.querySelector('#prototypeUploadContainer .submit-btn');
                if (btn) {
                    btn.disabled = false;
                    btn.textContent = '‚úì Subir Prototipo';
                }
            }
        }

        async function loadPrototypeStatus(gameSessionId) {
            try {
                if (!myTeamId || !currentActivityId || !currentSessionStageId) {
                    return;
                }

                const progressResponse = await fetch(
                    `${API_BASE_URL}/sessions/team-activity-progress/?team=${myTeamId}&activity=${currentActivityId}&session_stage=${currentSessionStageId}`
                );

                if (progressResponse.ok) {
                    const progressData = await progressResponse.json();
                    const progress = Array.isArray(progressData) ? progressData[0] : progressData.results?.[0];
                    
                    if (progress && progress.prototype_image_url) {
                        console.log('‚úÖ Prototipo ya subido, mostrando imagen:', progress.prototype_image_url);
                        
                        // Ocultar contenedor de subida
                        const uploadContainer = document.getElementById('prototypeUploadContainer');
                        if (uploadContainer) {
                            uploadContainer.style.display = 'none';
                        }
                        
                        // Mostrar imagen subida (ahora est√° fuera del contenedor de subida)
                        const uploadedImage = document.getElementById('prototypeUploadedImage');
                        const uploadedContainer = document.getElementById('prototypeUploaded');
                        if (uploadedImage && uploadedContainer) {
                            uploadedImage.src = progress.prototype_image_url;
                            uploadedContainer.style.display = 'block';
                            console.log('‚úÖ Prototipo cargado desde servidor y mostrado');
                        } else {
                            console.error('‚ùå No se encontraron elementos para mostrar prototipo cargado');
                        }
                        
                        // Ocultar preview
                        const preview = document.getElementById('prototypePreview');
                        if (preview) {
                            preview.style.display = 'none';
                        }
                        
                        // Limpiar selecci√≥n
                        selectedPrototypeImage = null;
                        const imageInput = document.getElementById('prototypeImageInput');
                        if (imageInput) {
                            imageInput.value = '';
                        }
                    } else {
                        // Si no hay prototipo, asegurar que los elementos est√©n visibles
                        const uploadedContainer = document.getElementById('prototypeUploaded');
                        const uploadContainer = document.getElementById('prototypeUploadContainer');
                        if (uploadedContainer) {
                            uploadedContainer.style.display = 'none';
                        }
                        if (uploadContainer) {
                            uploadContainer.style.display = 'block';
                        }
                    }
                }
            } catch (error) {
                console.error('Error loading prototype status:', error);
            }
        }
    </script>
</body>
</html>

